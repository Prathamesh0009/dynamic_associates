"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-18-image-lightbox";
exports.ids = ["vendor-chunks/react-18-image-lightbox"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-18-image-lightbox/style.css":
/*!********************************************************!*\
  !*** ./node_modules/react-18-image-lightbox/style.css ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"0e4852f3bf48\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtMTgtaW1hZ2UtbGlnaHRib3gvc3R5bGUuY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RhcnQtYXBwLWRpci8uL25vZGVfbW9kdWxlcy9yZWFjdC0xOC1pbWFnZS1saWdodGJveC9zdHlsZS5jc3M/ZmQ0NCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjBlNDg1MmYzYmY0OFwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-18-image-lightbox/style.css\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-18-image-lightbox/dist/index.es.js":
/*!***************************************************************!*\
  !*** ./node_modules/react-18-image-lightbox/dist/index.es.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ReactImageLightbox)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react_modal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-modal */ \"(ssr)/./node_modules/react-modal/lib/index.js\");\n/* harmony import */ var react_modal__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_modal__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\n/**\n * Placeholder for future translate functionality\n */\nfunction translate(str) {\n  var replaceStrings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n  if (!str) {\n    return '';\n  }\n\n  var translated = str;\n\n  if (replaceStrings) {\n    Object.keys(replaceStrings).forEach(function (placeholder) {\n      translated = translated.replace(placeholder, replaceStrings[placeholder]);\n    });\n  }\n\n  return translated;\n}\nfunction getWindowWidth() {\n  return typeof global.window !== 'undefined' ? global.window.innerWidth : 0;\n}\nfunction getWindowHeight() {\n  return typeof global.window !== 'undefined' ? global.window.innerHeight : 0;\n}\n\nvar isCrossOriginFrame = function isCrossOriginFrame() {\n  try {\n    return global.window.location.hostname !== global.window.parent.location.hostname;\n  } catch (e) {\n    return true;\n  }\n}; // Get the highest window context that isn't cross-origin\n// (When in an iframe)\n\n\nfunction getHighestSafeWindowContext() {\n  var self = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : global.window.self;\n\n  // If we reached the top level, return self\n  if (self === global.window.top) {\n    return self;\n  } // If parent is the same origin, we can move up one context\n  // Reference: https://stackoverflow.com/a/21965342/1601953\n\n\n  if (!isCrossOriginFrame()) {\n    return getHighestSafeWindowContext(self.parent);\n  } // If a different origin, we consider the current level\n  // as the top reachable one\n\n\n  return self;\n}\n\n// Min image zoom level\nvar MIN_ZOOM_LEVEL = 0; // Max image zoom level\n\nvar MAX_ZOOM_LEVEL = 300; // Size ratio between previous and next zoom levels\n\nvar ZOOM_RATIO = 1.007; // How much to increase/decrease the zoom level when the zoom buttons are clicked\n\nvar ZOOM_BUTTON_INCREMENT_SIZE = 100; // Used to judge the amount of horizontal scroll needed to initiate a image move\n\nvar WHEEL_MOVE_X_THRESHOLD = 200; // Used to judge the amount of vertical scroll needed to initiate a zoom action\n\nvar WHEEL_MOVE_Y_THRESHOLD = 1;\nvar KEYS = {\n  ESC: 27,\n  LEFT_ARROW: 37,\n  RIGHT_ARROW: 39\n}; // Actions\n\nvar ACTION_NONE = 0;\nvar ACTION_MOVE = 1;\nvar ACTION_SWIPE = 2;\nvar ACTION_PINCH = 3;\n\nvar SOURCE_ANY = 0;\nvar SOURCE_MOUSE = 1;\nvar SOURCE_TOUCH = 2;\nvar SOURCE_POINTER = 3; // Minimal swipe distance\n\nvar MIN_SWIPE_DISTANCE = 200;\n\nvar ReactImageLightbox = /*#__PURE__*/function (_Component) {\n  _inherits(ReactImageLightbox, _Component);\n\n  var _super = _createSuper(ReactImageLightbox);\n\n  function ReactImageLightbox(props) {\n    var _this;\n\n    _classCallCheck(this, ReactImageLightbox);\n\n    _this = _super.call(this, props);\n    _this.state = {\n      //-----------------------------\n      // Animation\n      //-----------------------------\n      // Lightbox is closing\n      // When Lightbox is mounted, if animation is enabled it will open with the reverse of the closing animation\n      isClosing: !props.animationDisabled,\n      // Component parts should animate (e.g., when images are moving, or image is being zoomed)\n      shouldAnimate: false,\n      //-----------------------------\n      // Zoom settings\n      //-----------------------------\n      // Zoom level of image\n      zoomLevel: MIN_ZOOM_LEVEL,\n      //-----------------------------\n      // Image position settings\n      //-----------------------------\n      // Horizontal offset from center\n      offsetX: 0,\n      // Vertical offset from center\n      offsetY: 0,\n      // image load error for srcType\n      loadErrorStatus: {}\n    }; // Refs\n\n    _this.outerEl = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createRef();\n    _this.zoomInBtn = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createRef();\n    _this.zoomOutBtn = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createRef();\n    _this.caption = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createRef();\n    _this.closeIfClickInner = _this.closeIfClickInner.bind(_assertThisInitialized(_this));\n    _this.handleImageDoubleClick = _this.handleImageDoubleClick.bind(_assertThisInitialized(_this));\n    _this.handleImageMouseWheel = _this.handleImageMouseWheel.bind(_assertThisInitialized(_this));\n    _this.handleKeyInput = _this.handleKeyInput.bind(_assertThisInitialized(_this));\n    _this.handleMouseUp = _this.handleMouseUp.bind(_assertThisInitialized(_this));\n    _this.handleMouseDown = _this.handleMouseDown.bind(_assertThisInitialized(_this));\n    _this.handleMouseMove = _this.handleMouseMove.bind(_assertThisInitialized(_this));\n    _this.handleOuterMousewheel = _this.handleOuterMousewheel.bind(_assertThisInitialized(_this));\n    _this.handleTouchStart = _this.handleTouchStart.bind(_assertThisInitialized(_this));\n    _this.handleTouchMove = _this.handleTouchMove.bind(_assertThisInitialized(_this));\n    _this.handleTouchEnd = _this.handleTouchEnd.bind(_assertThisInitialized(_this));\n    _this.handlePointerEvent = _this.handlePointerEvent.bind(_assertThisInitialized(_this));\n    _this.handleCaptionMousewheel = _this.handleCaptionMousewheel.bind(_assertThisInitialized(_this));\n    _this.handleWindowResize = _this.handleWindowResize.bind(_assertThisInitialized(_this));\n    _this.handleZoomInButtonClick = _this.handleZoomInButtonClick.bind(_assertThisInitialized(_this));\n    _this.handleZoomOutButtonClick = _this.handleZoomOutButtonClick.bind(_assertThisInitialized(_this));\n    _this.requestClose = _this.requestClose.bind(_assertThisInitialized(_this));\n    _this.requestMoveNext = _this.requestMoveNext.bind(_assertThisInitialized(_this));\n    _this.requestMovePrev = _this.requestMovePrev.bind(_assertThisInitialized(_this)); // Timeouts - always clear it before umount\n\n    _this.timeouts = []; // Current action\n\n    _this.currentAction = ACTION_NONE; // Events source\n\n    _this.eventsSource = SOURCE_ANY; // Empty pointers list\n\n    _this.pointerList = []; // Prevent inner close\n\n    _this.preventInnerClose = false;\n    _this.preventInnerCloseTimeout = null; // Used to disable animation when changing props.mainSrc|nextSrc|prevSrc\n\n    _this.keyPressed = false; // Used to store load state / dimensions of images\n\n    _this.imageCache = {}; // Time the last keydown event was called (used in keyboard action rate limiting)\n\n    _this.lastKeyDownTime = 0; // Used for debouncing window resize event\n\n    _this.resizeTimeout = null; // Used to determine when actions are triggered by the scroll wheel\n\n    _this.wheelActionTimeout = null;\n    _this.resetScrollTimeout = null;\n    _this.scrollX = 0;\n    _this.scrollY = 0; // Used in panning zoomed images\n\n    _this.moveStartX = 0;\n    _this.moveStartY = 0;\n    _this.moveStartOffsetX = 0;\n    _this.moveStartOffsetY = 0; // Used to swipe\n\n    _this.swipeStartX = 0;\n    _this.swipeStartY = 0;\n    _this.swipeEndX = 0;\n    _this.swipeEndY = 0; // Used to pinch\n\n    _this.pinchTouchList = null;\n    _this.pinchDistance = 0; // Used to differentiate between images with identical src\n\n    _this.keyCounter = 0; // Used to detect a move when all src's remain unchanged (four or more of the same image in a row)\n\n    _this.moveRequested = false;\n    return _this;\n  }\n\n  _createClass(ReactImageLightbox, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      if (!this.props.animationDisabled) {\n        // Make opening animation play\n        this.setState({\n          isClosing: false\n        });\n      } // Prevents cross-origin errors when using a cross-origin iframe\n\n\n      this.windowContext = getHighestSafeWindowContext();\n      this.listeners = {\n        resize: this.handleWindowResize,\n        mouseup: this.handleMouseUp,\n        touchend: this.handleTouchEnd,\n        touchcancel: this.handleTouchEnd,\n        pointerdown: this.handlePointerEvent,\n        pointermove: this.handlePointerEvent,\n        pointerup: this.handlePointerEvent,\n        pointercancel: this.handlePointerEvent\n      };\n      Object.keys(this.listeners).forEach(function (type) {\n        _this2.windowContext.addEventListener(type, _this2.listeners[type]);\n      });\n      this.loadAllImages();\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps) {\n      var _this3 = this;\n\n      this.getSrcTypes().forEach(function (srcType) {\n        if (_this3.props[srcType.name] !== nextProps[srcType.name]) {\n          _this3.moveRequested = false;\n        }\n      }); // Wait for move...\n\n      return !this.moveRequested;\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var _this4 = this;\n\n      var sourcesChanged = false;\n      var prevSrcDict = {};\n      var nextSrcDict = {};\n      this.getSrcTypes().forEach(function (srcType) {\n        if (prevProps[srcType.name] !== _this4.props[srcType.name]) {\n          sourcesChanged = true;\n          prevSrcDict[prevProps[srcType.name]] = true;\n          nextSrcDict[_this4.props[srcType.name]] = true;\n        }\n      });\n\n      if (sourcesChanged || this.moveRequested) {\n        // Reset the loaded state for images not rendered next\n        Object.keys(prevSrcDict).forEach(function (prevSrc) {\n          if (!(prevSrc in nextSrcDict) && prevSrc in _this4.imageCache) {\n            _this4.imageCache[prevSrc].loaded = false;\n          }\n        });\n        this.moveRequested = false; // Load any new images\n\n        this.loadAllImages(this.props);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      var _this5 = this;\n\n      this.didUnmount = true;\n      Object.keys(this.listeners).forEach(function (type) {\n        _this5.windowContext.removeEventListener(type, _this5.listeners[type]);\n      });\n      this.timeouts.forEach(function (tid) {\n        return clearTimeout(tid);\n      });\n    }\n  }, {\n    key: \"setTimeout\",\n    value: function (_setTimeout) {\n      function setTimeout(_x, _x2) {\n        return _setTimeout.apply(this, arguments);\n      }\n\n      setTimeout.toString = function () {\n        return _setTimeout.toString();\n      };\n\n      return setTimeout;\n    }(function (func, time) {\n      var _this6 = this;\n\n      var id = setTimeout(function () {\n        _this6.timeouts = _this6.timeouts.filter(function (tid) {\n          return tid !== id;\n        });\n        func();\n      }, time);\n      this.timeouts.push(id);\n      return id;\n    })\n  }, {\n    key: \"setPreventInnerClose\",\n    value: function setPreventInnerClose() {\n      var _this7 = this;\n\n      if (this.preventInnerCloseTimeout) {\n        this.clearTimeout(this.preventInnerCloseTimeout);\n      }\n\n      this.preventInnerClose = true;\n      this.preventInnerCloseTimeout = this.setTimeout(function () {\n        _this7.preventInnerClose = false;\n        _this7.preventInnerCloseTimeout = null;\n      }, 100);\n    } // Get info for the best suited image to display with the given srcType\n\n  }, {\n    key: \"getBestImageForType\",\n    value: function getBestImageForType(srcType) {\n      var imageSrc = this.props[srcType];\n      var fitSizes = {};\n\n      if (this.isImageLoaded(imageSrc)) {\n        // Use full-size image if available\n        fitSizes = this.getFitSizes(this.imageCache[imageSrc].width, this.imageCache[imageSrc].height);\n      } else if (this.isImageLoaded(this.props[\"\".concat(srcType, \"Thumbnail\")])) {\n        // Fall back to using thumbnail if the image has not been loaded\n        imageSrc = this.props[\"\".concat(srcType, \"Thumbnail\")];\n        fitSizes = this.getFitSizes(this.imageCache[imageSrc].width, this.imageCache[imageSrc].height, true);\n      } else {\n        return null;\n      }\n\n      return {\n        src: imageSrc,\n        height: this.imageCache[imageSrc].height,\n        width: this.imageCache[imageSrc].width,\n        targetHeight: fitSizes.height,\n        targetWidth: fitSizes.width\n      };\n    } // Get sizing for when an image is larger than the window\n\n  }, {\n    key: \"getFitSizes\",\n    value: function getFitSizes(width, height, stretch) {\n      var boxSize = this.getLightboxRect();\n      var maxHeight = boxSize.height - this.props.imagePadding * 2;\n      var maxWidth = boxSize.width - this.props.imagePadding * 2;\n\n      if (!stretch) {\n        maxHeight = Math.min(maxHeight, height);\n        maxWidth = Math.min(maxWidth, width);\n      }\n\n      var maxRatio = maxWidth / maxHeight;\n      var srcRatio = width / height;\n\n      if (maxRatio > srcRatio) {\n        // height is the constraining dimension of the photo\n        return {\n          width: width * maxHeight / height,\n          height: maxHeight\n        };\n      }\n\n      return {\n        width: maxWidth,\n        height: height * maxWidth / width\n      };\n    }\n  }, {\n    key: \"getMaxOffsets\",\n    value: function getMaxOffsets() {\n      var zoomLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.zoomLevel;\n      var currentImageInfo = this.getBestImageForType('mainSrc');\n\n      if (currentImageInfo === null) {\n        return {\n          maxX: 0,\n          minX: 0,\n          maxY: 0,\n          minY: 0\n        };\n      }\n\n      var boxSize = this.getLightboxRect();\n      var zoomMultiplier = this.getZoomMultiplier(zoomLevel);\n      var maxX = 0;\n\n      if (zoomMultiplier * currentImageInfo.width - boxSize.width < 0) {\n        // if there is still blank space in the X dimension, don't limit except to the opposite edge\n        maxX = (boxSize.width - zoomMultiplier * currentImageInfo.width) / 2;\n      } else {\n        maxX = (zoomMultiplier * currentImageInfo.width - boxSize.width) / 2;\n      }\n\n      var maxY = 0;\n\n      if (zoomMultiplier * currentImageInfo.height - boxSize.height < 0) {\n        // if there is still blank space in the Y dimension, don't limit except to the opposite edge\n        maxY = (boxSize.height - zoomMultiplier * currentImageInfo.height) / 2;\n      } else {\n        maxY = (zoomMultiplier * currentImageInfo.height - boxSize.height) / 2;\n      }\n\n      return {\n        maxX: maxX,\n        maxY: maxY,\n        minX: -1 * maxX,\n        minY: -1 * maxY\n      };\n    } // Get image src types\n\n  }, {\n    key: \"getSrcTypes\",\n    value: function getSrcTypes() {\n      return [{\n        name: 'mainSrc',\n        keyEnding: \"i\".concat(this.keyCounter)\n      }, {\n        name: 'mainSrcThumbnail',\n        keyEnding: \"t\".concat(this.keyCounter)\n      }, {\n        name: 'nextSrc',\n        keyEnding: \"i\".concat(this.keyCounter + 1)\n      }, {\n        name: 'nextSrcThumbnail',\n        keyEnding: \"t\".concat(this.keyCounter + 1)\n      }, {\n        name: 'prevSrc',\n        keyEnding: \"i\".concat(this.keyCounter - 1)\n      }, {\n        name: 'prevSrcThumbnail',\n        keyEnding: \"t\".concat(this.keyCounter - 1)\n      }];\n    }\n    /**\n     * Get sizing when the image is scaled\n     */\n\n  }, {\n    key: \"getZoomMultiplier\",\n    value: function getZoomMultiplier() {\n      var zoomLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.zoomLevel;\n      return Math.pow(ZOOM_RATIO, zoomLevel);\n    }\n    /**\n     * Get the size of the lightbox in pixels\n     */\n\n  }, {\n    key: \"getLightboxRect\",\n    value: function getLightboxRect() {\n      if (this.outerEl.current) {\n        return this.outerEl.current.getBoundingClientRect();\n      }\n\n      return {\n        width: getWindowWidth(),\n        height: getWindowHeight(),\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      };\n    }\n  }, {\n    key: \"clearTimeout\",\n    value: function (_clearTimeout) {\n      function clearTimeout(_x3) {\n        return _clearTimeout.apply(this, arguments);\n      }\n\n      clearTimeout.toString = function () {\n        return _clearTimeout.toString();\n      };\n\n      return clearTimeout;\n    }(function (id) {\n      this.timeouts = this.timeouts.filter(function (tid) {\n        return tid !== id;\n      });\n      clearTimeout(id);\n    } // Change zoom level\n    )\n  }, {\n    key: \"changeZoom\",\n    value: function changeZoom(zoomLevel, clientX, clientY) {\n      // Ignore if zoom disabled\n      if (!this.props.enableZoom) {\n        return;\n      } // Constrain zoom level to the set bounds\n\n\n      var nextZoomLevel = Math.max(MIN_ZOOM_LEVEL, Math.min(MAX_ZOOM_LEVEL, zoomLevel)); // Ignore requests that don't change the zoom level\n\n      if (nextZoomLevel === this.state.zoomLevel) {\n        return;\n      }\n\n      if (nextZoomLevel === MIN_ZOOM_LEVEL) {\n        // Snap back to center if zoomed all the way out\n        this.setState({\n          zoomLevel: nextZoomLevel,\n          offsetX: 0,\n          offsetY: 0\n        });\n        return;\n      }\n\n      var imageBaseSize = this.getBestImageForType('mainSrc');\n\n      if (imageBaseSize === null) {\n        return;\n      }\n\n      var currentZoomMultiplier = this.getZoomMultiplier();\n      var nextZoomMultiplier = this.getZoomMultiplier(nextZoomLevel); // Default to the center of the image to zoom when no mouse position specified\n\n      var boxRect = this.getLightboxRect();\n      var pointerX = typeof clientX !== 'undefined' ? clientX - boxRect.left : boxRect.width / 2;\n      var pointerY = typeof clientY !== 'undefined' ? clientY - boxRect.top : boxRect.height / 2;\n      var currentImageOffsetX = (boxRect.width - imageBaseSize.width * currentZoomMultiplier) / 2;\n      var currentImageOffsetY = (boxRect.height - imageBaseSize.height * currentZoomMultiplier) / 2;\n      var currentImageRealOffsetX = currentImageOffsetX - this.state.offsetX;\n      var currentImageRealOffsetY = currentImageOffsetY - this.state.offsetY;\n      var currentPointerXRelativeToImage = (pointerX - currentImageRealOffsetX) / currentZoomMultiplier;\n      var currentPointerYRelativeToImage = (pointerY - currentImageRealOffsetY) / currentZoomMultiplier;\n      var nextImageRealOffsetX = pointerX - currentPointerXRelativeToImage * nextZoomMultiplier;\n      var nextImageRealOffsetY = pointerY - currentPointerYRelativeToImage * nextZoomMultiplier;\n      var nextImageOffsetX = (boxRect.width - imageBaseSize.width * nextZoomMultiplier) / 2;\n      var nextImageOffsetY = (boxRect.height - imageBaseSize.height * nextZoomMultiplier) / 2;\n      var nextOffsetX = nextImageOffsetX - nextImageRealOffsetX;\n      var nextOffsetY = nextImageOffsetY - nextImageRealOffsetY; // When zooming out, limit the offset so things don't get left askew\n\n      if (this.currentAction !== ACTION_PINCH) {\n        var maxOffsets = this.getMaxOffsets();\n\n        if (this.state.zoomLevel > nextZoomLevel) {\n          nextOffsetX = Math.max(maxOffsets.minX, Math.min(maxOffsets.maxX, nextOffsetX));\n          nextOffsetY = Math.max(maxOffsets.minY, Math.min(maxOffsets.maxY, nextOffsetY));\n        }\n      }\n\n      this.setState({\n        zoomLevel: nextZoomLevel,\n        offsetX: nextOffsetX,\n        offsetY: nextOffsetY\n      });\n    }\n  }, {\n    key: \"closeIfClickInner\",\n    value: function closeIfClickInner(event) {\n      if (!this.preventInnerClose && event.target.className.search(/\\bril-inner\\b/) > -1) {\n        this.requestClose(event);\n      }\n    }\n    /**\n     * Handle user keyboard actions\n     */\n\n  }, {\n    key: \"handleKeyInput\",\n    value: function handleKeyInput(event) {\n      event.stopPropagation(); // Ignore key input during animations\n\n      if (this.isAnimating()) {\n        return;\n      } // Allow slightly faster navigation through the images when user presses keys repeatedly\n\n\n      if (event.type === 'keyup') {\n        this.lastKeyDownTime -= this.props.keyRepeatKeyupBonus;\n        return;\n      }\n\n      var keyCode = event.which || event.keyCode; // Ignore key presses that happen too close to each other (when rapid fire key pressing or holding down the key)\n      // But allow it if it's a lightbox closing action\n\n      var currentTime = new Date();\n\n      if (currentTime.getTime() - this.lastKeyDownTime < this.props.keyRepeatLimit && keyCode !== KEYS.ESC) {\n        return;\n      }\n\n      this.lastKeyDownTime = currentTime.getTime();\n\n      switch (keyCode) {\n        // ESC key closes the lightbox\n        case KEYS.ESC:\n          event.preventDefault();\n          this.requestClose(event);\n          break;\n        // Left arrow key moves to previous image\n\n        case KEYS.LEFT_ARROW:\n          if (!this.props.prevSrc) {\n            return;\n          }\n\n          event.preventDefault();\n          this.keyPressed = true;\n          this.requestMovePrev(event);\n          break;\n        // Right arrow key moves to next image\n\n        case KEYS.RIGHT_ARROW:\n          if (!this.props.nextSrc) {\n            return;\n          }\n\n          event.preventDefault();\n          this.keyPressed = true;\n          this.requestMoveNext(event);\n          break;\n      }\n    }\n    /**\n     * Handle a mouse wheel event over the lightbox container\n     */\n\n  }, {\n    key: \"handleOuterMousewheel\",\n    value: function handleOuterMousewheel(event) {\n      var _this8 = this;\n\n      // Prevent scrolling of the background\n      event.stopPropagation();\n      var xThreshold = WHEEL_MOVE_X_THRESHOLD;\n      var actionDelay = 0;\n      var imageMoveDelay = 500;\n      this.clearTimeout(this.resetScrollTimeout);\n      this.resetScrollTimeout = this.setTimeout(function () {\n        _this8.scrollX = 0;\n        _this8.scrollY = 0;\n      }, 300); // Prevent rapid-fire zoom behavior\n\n      if (this.wheelActionTimeout !== null || this.isAnimating()) {\n        return;\n      }\n\n      if (Math.abs(event.deltaY) < Math.abs(event.deltaX)) {\n        // handle horizontal scrolls with image moves\n        this.scrollY = 0;\n        this.scrollX += event.deltaX;\n        var bigLeapX = xThreshold / 2; // If the scroll amount has accumulated sufficiently, or a large leap was taken\n\n        if (this.scrollX >= xThreshold || event.deltaX >= bigLeapX) {\n          // Scroll right moves to next\n          this.requestMoveNext(event);\n          actionDelay = imageMoveDelay;\n          this.scrollX = 0;\n        } else if (this.scrollX <= -1 * xThreshold || event.deltaX <= -1 * bigLeapX) {\n          // Scroll left moves to previous\n          this.requestMovePrev(event);\n          actionDelay = imageMoveDelay;\n          this.scrollX = 0;\n        }\n      } // Allow successive actions after the set delay\n\n\n      if (actionDelay !== 0) {\n        this.wheelActionTimeout = this.setTimeout(function () {\n          _this8.wheelActionTimeout = null;\n        }, actionDelay);\n      }\n    }\n  }, {\n    key: \"handleImageMouseWheel\",\n    value: function handleImageMouseWheel(event) {\n      var yThreshold = WHEEL_MOVE_Y_THRESHOLD;\n\n      if (Math.abs(event.deltaY) >= Math.abs(event.deltaX)) {\n        event.stopPropagation(); // If the vertical scroll amount was large enough, perform a zoom\n\n        if (Math.abs(event.deltaY) < yThreshold) {\n          return;\n        }\n\n        this.scrollX = 0;\n        this.scrollY += event.deltaY;\n        this.changeZoom(this.state.zoomLevel - event.deltaY, event.clientX, event.clientY);\n      }\n    }\n    /**\n     * Handle a double click on the current image\n     */\n\n  }, {\n    key: \"handleImageDoubleClick\",\n    value: function handleImageDoubleClick(event) {\n      if (this.state.zoomLevel > MIN_ZOOM_LEVEL) {\n        // A double click when zoomed in zooms all the way out\n        this.changeZoom(MIN_ZOOM_LEVEL, event.clientX, event.clientY);\n      } else {\n        // A double click when zoomed all the way out zooms in\n        this.changeZoom(this.state.zoomLevel + ZOOM_BUTTON_INCREMENT_SIZE, event.clientX, event.clientY);\n      }\n    }\n  }, {\n    key: \"shouldHandleEvent\",\n    value: function shouldHandleEvent(source) {\n      if (this.eventsSource === source) {\n        return true;\n      }\n\n      if (this.eventsSource === SOURCE_ANY) {\n        this.eventsSource = source;\n        return true;\n      }\n\n      switch (source) {\n        case SOURCE_MOUSE:\n          return false;\n\n        case SOURCE_TOUCH:\n          this.eventsSource = SOURCE_TOUCH;\n          this.filterPointersBySource();\n          return true;\n\n        case SOURCE_POINTER:\n          if (this.eventsSource === SOURCE_MOUSE) {\n            this.eventsSource = SOURCE_POINTER;\n            this.filterPointersBySource();\n            return true;\n          }\n\n          return false;\n\n        default:\n          return false;\n      }\n    }\n  }, {\n    key: \"addPointer\",\n    value: function addPointer(pointer) {\n      this.pointerList.push(pointer);\n    }\n  }, {\n    key: \"removePointer\",\n    value: function removePointer(pointer) {\n      this.pointerList = this.pointerList.filter(function (_ref) {\n        var id = _ref.id;\n        return id !== pointer.id;\n      });\n    }\n  }, {\n    key: \"filterPointersBySource\",\n    value: function filterPointersBySource() {\n      var _this9 = this;\n\n      this.pointerList = this.pointerList.filter(function (_ref2) {\n        var source = _ref2.source;\n        return source === _this9.eventsSource;\n      });\n    }\n  }, {\n    key: \"handleMouseDown\",\n    value: function handleMouseDown(event) {\n      if (this.shouldHandleEvent(SOURCE_MOUSE) && ReactImageLightbox.isTargetMatchImage(event.target)) {\n        this.addPointer(ReactImageLightbox.parseMouseEvent(event));\n        this.multiPointerStart(event);\n      }\n    }\n  }, {\n    key: \"handleMouseMove\",\n    value: function handleMouseMove(event) {\n      if (this.shouldHandleEvent(SOURCE_MOUSE)) {\n        this.multiPointerMove(event, [ReactImageLightbox.parseMouseEvent(event)]);\n      }\n    }\n  }, {\n    key: \"handleMouseUp\",\n    value: function handleMouseUp(event) {\n      if (this.shouldHandleEvent(SOURCE_MOUSE)) {\n        this.removePointer(ReactImageLightbox.parseMouseEvent(event));\n        this.multiPointerEnd(event);\n      }\n    }\n  }, {\n    key: \"handlePointerEvent\",\n    value: function handlePointerEvent(event) {\n      if (this.shouldHandleEvent(SOURCE_POINTER)) {\n        switch (event.type) {\n          case 'pointerdown':\n            if (ReactImageLightbox.isTargetMatchImage(event.target)) {\n              this.addPointer(ReactImageLightbox.parsePointerEvent(event));\n              this.multiPointerStart(event);\n            }\n\n            break;\n\n          case 'pointermove':\n            this.multiPointerMove(event, [ReactImageLightbox.parsePointerEvent(event)]);\n            break;\n\n          case 'pointerup':\n          case 'pointercancel':\n            this.removePointer(ReactImageLightbox.parsePointerEvent(event));\n            this.multiPointerEnd(event);\n            break;\n        }\n      }\n    }\n  }, {\n    key: \"handleTouchStart\",\n    value: function handleTouchStart(event) {\n      var _this10 = this;\n\n      if (this.shouldHandleEvent(SOURCE_TOUCH) && ReactImageLightbox.isTargetMatchImage(event.target)) {\n        [].forEach.call(event.changedTouches, function (eventTouch) {\n          return _this10.addPointer(ReactImageLightbox.parseTouchPointer(eventTouch));\n        });\n        this.multiPointerStart(event);\n      }\n    }\n  }, {\n    key: \"handleTouchMove\",\n    value: function handleTouchMove(event) {\n      if (this.shouldHandleEvent(SOURCE_TOUCH)) {\n        this.multiPointerMove(event, [].map.call(event.changedTouches, function (eventTouch) {\n          return ReactImageLightbox.parseTouchPointer(eventTouch);\n        }));\n      }\n    }\n  }, {\n    key: \"handleTouchEnd\",\n    value: function handleTouchEnd(event) {\n      var _this11 = this;\n\n      if (this.shouldHandleEvent(SOURCE_TOUCH)) {\n        [].map.call(event.changedTouches, function (touch) {\n          return _this11.removePointer(ReactImageLightbox.parseTouchPointer(touch));\n        });\n        this.multiPointerEnd(event);\n      }\n    }\n  }, {\n    key: \"decideMoveOrSwipe\",\n    value: function decideMoveOrSwipe(pointer) {\n      if (this.state.zoomLevel <= MIN_ZOOM_LEVEL) {\n        this.handleSwipeStart(pointer);\n      } else {\n        this.handleMoveStart(pointer);\n      }\n    }\n  }, {\n    key: \"multiPointerStart\",\n    value: function multiPointerStart(event) {\n      this.handleEnd(null);\n\n      switch (this.pointerList.length) {\n        case 1:\n          {\n            event.preventDefault();\n            this.decideMoveOrSwipe(this.pointerList[0]);\n            break;\n          }\n\n        case 2:\n          {\n            event.preventDefault();\n            this.handlePinchStart(this.pointerList);\n            break;\n          }\n      }\n    }\n  }, {\n    key: \"multiPointerMove\",\n    value: function multiPointerMove(event, pointerList) {\n      switch (this.currentAction) {\n        case ACTION_MOVE:\n          {\n            event.preventDefault();\n            this.handleMove(pointerList[0]);\n            break;\n          }\n\n        case ACTION_SWIPE:\n          {\n            event.preventDefault();\n            this.handleSwipe(pointerList[0]);\n            break;\n          }\n\n        case ACTION_PINCH:\n          {\n            event.preventDefault();\n            this.handlePinch(pointerList);\n            break;\n          }\n      }\n    }\n  }, {\n    key: \"multiPointerEnd\",\n    value: function multiPointerEnd(event) {\n      if (this.currentAction !== ACTION_NONE) {\n        this.setPreventInnerClose();\n        this.handleEnd(event);\n      }\n\n      switch (this.pointerList.length) {\n        case 0:\n          {\n            this.eventsSource = SOURCE_ANY;\n            break;\n          }\n\n        case 1:\n          {\n            event.preventDefault();\n            this.decideMoveOrSwipe(this.pointerList[0]);\n            break;\n          }\n\n        case 2:\n          {\n            event.preventDefault();\n            this.handlePinchStart(this.pointerList);\n            break;\n          }\n      }\n    }\n  }, {\n    key: \"handleEnd\",\n    value: function handleEnd(event) {\n      switch (this.currentAction) {\n        case ACTION_MOVE:\n          this.handleMoveEnd(event);\n          break;\n\n        case ACTION_SWIPE:\n          this.handleSwipeEnd(event);\n          break;\n\n        case ACTION_PINCH:\n          this.handlePinchEnd(event);\n          break;\n      }\n    } // Handle move start over the lightbox container\n    // This happens:\n    // - On a mouseDown event\n    // - On a touchstart event\n\n  }, {\n    key: \"handleMoveStart\",\n    value: function handleMoveStart(_ref3) {\n      var clientX = _ref3.x,\n          clientY = _ref3.y;\n\n      if (!this.props.enableZoom) {\n        return;\n      }\n\n      this.currentAction = ACTION_MOVE;\n      this.moveStartX = clientX;\n      this.moveStartY = clientY;\n      this.moveStartOffsetX = this.state.offsetX;\n      this.moveStartOffsetY = this.state.offsetY;\n    } // Handle dragging over the lightbox container\n    // This happens:\n    // - After a mouseDown and before a mouseUp event\n    // - After a touchstart and before a touchend event\n\n  }, {\n    key: \"handleMove\",\n    value: function handleMove(_ref4) {\n      var clientX = _ref4.x,\n          clientY = _ref4.y;\n      var newOffsetX = this.moveStartX - clientX + this.moveStartOffsetX;\n      var newOffsetY = this.moveStartY - clientY + this.moveStartOffsetY;\n\n      if (this.state.offsetX !== newOffsetX || this.state.offsetY !== newOffsetY) {\n        this.setState({\n          offsetX: newOffsetX,\n          offsetY: newOffsetY\n        });\n      }\n    }\n  }, {\n    key: \"handleMoveEnd\",\n    value: function handleMoveEnd() {\n      var _this12 = this;\n\n      this.currentAction = ACTION_NONE;\n      this.moveStartX = 0;\n      this.moveStartY = 0;\n      this.moveStartOffsetX = 0;\n      this.moveStartOffsetY = 0; // Snap image back into frame if outside max offset range\n\n      var maxOffsets = this.getMaxOffsets();\n      var nextOffsetX = Math.max(maxOffsets.minX, Math.min(maxOffsets.maxX, this.state.offsetX));\n      var nextOffsetY = Math.max(maxOffsets.minY, Math.min(maxOffsets.maxY, this.state.offsetY));\n\n      if (nextOffsetX !== this.state.offsetX || nextOffsetY !== this.state.offsetY) {\n        this.setState({\n          offsetX: nextOffsetX,\n          offsetY: nextOffsetY,\n          shouldAnimate: true\n        });\n        this.setTimeout(function () {\n          _this12.setState({\n            shouldAnimate: false\n          });\n        }, this.props.animationDuration);\n      }\n    }\n  }, {\n    key: \"handleSwipeStart\",\n    value: function handleSwipeStart(_ref5) {\n      var clientX = _ref5.x,\n          clientY = _ref5.y;\n      this.currentAction = ACTION_SWIPE;\n      this.swipeStartX = clientX;\n      this.swipeStartY = clientY;\n      this.swipeEndX = clientX;\n      this.swipeEndY = clientY;\n    }\n  }, {\n    key: \"handleSwipe\",\n    value: function handleSwipe(_ref6) {\n      var clientX = _ref6.x,\n          clientY = _ref6.y;\n      this.swipeEndX = clientX;\n      this.swipeEndY = clientY;\n    }\n  }, {\n    key: \"handleSwipeEnd\",\n    value: function handleSwipeEnd(event) {\n      var xDiff = this.swipeEndX - this.swipeStartX;\n      var xDiffAbs = Math.abs(xDiff);\n      var yDiffAbs = Math.abs(this.swipeEndY - this.swipeStartY);\n      this.currentAction = ACTION_NONE;\n      this.swipeStartX = 0;\n      this.swipeStartY = 0;\n      this.swipeEndX = 0;\n      this.swipeEndY = 0;\n\n      if (!event || this.isAnimating() || xDiffAbs < yDiffAbs * 1.5) {\n        return;\n      }\n\n      if (xDiffAbs < MIN_SWIPE_DISTANCE) {\n        var boxRect = this.getLightboxRect();\n\n        if (xDiffAbs < boxRect.width / 4) {\n          return;\n        }\n      }\n\n      if (xDiff > 0 && this.props.prevSrc) {\n        event.preventDefault();\n        this.requestMovePrev();\n      } else if (xDiff < 0 && this.props.nextSrc) {\n        event.preventDefault();\n        this.requestMoveNext();\n      }\n    }\n  }, {\n    key: \"calculatePinchDistance\",\n    value: function calculatePinchDistance() {\n      var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.pinchTouchList,\n          _ref8 = _slicedToArray(_ref7, 2),\n          a = _ref8[0],\n          b = _ref8[1];\n\n      return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n    }\n  }, {\n    key: \"calculatePinchCenter\",\n    value: function calculatePinchCenter() {\n      var _ref9 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.pinchTouchList,\n          _ref10 = _slicedToArray(_ref9, 2),\n          a = _ref10[0],\n          b = _ref10[1];\n\n      return {\n        x: a.x - (a.x - b.x) / 2,\n        y: a.y - (a.y - b.y) / 2\n      };\n    }\n  }, {\n    key: \"handlePinchStart\",\n    value: function handlePinchStart(pointerList) {\n      if (!this.props.enableZoom) {\n        return;\n      }\n\n      this.currentAction = ACTION_PINCH;\n      this.pinchTouchList = pointerList.map(function (_ref11) {\n        var id = _ref11.id,\n            x = _ref11.x,\n            y = _ref11.y;\n        return {\n          id: id,\n          x: x,\n          y: y\n        };\n      });\n      this.pinchDistance = this.calculatePinchDistance();\n    }\n  }, {\n    key: \"handlePinch\",\n    value: function handlePinch(pointerList) {\n      this.pinchTouchList = this.pinchTouchList.map(function (oldPointer) {\n        for (var i = 0; i < pointerList.length; i += 1) {\n          if (pointerList[i].id === oldPointer.id) {\n            return pointerList[i];\n          }\n        }\n\n        return oldPointer;\n      });\n      var newDistance = this.calculatePinchDistance();\n      var zoomLevel = this.state.zoomLevel + newDistance - this.pinchDistance;\n      this.pinchDistance = newDistance;\n\n      var _this$calculatePinchC = this.calculatePinchCenter(this.pinchTouchList),\n          clientX = _this$calculatePinchC.x,\n          clientY = _this$calculatePinchC.y;\n\n      this.changeZoom(zoomLevel, clientX, clientY);\n    }\n  }, {\n    key: \"handlePinchEnd\",\n    value: function handlePinchEnd() {\n      this.currentAction = ACTION_NONE;\n      this.pinchTouchList = null;\n      this.pinchDistance = 0;\n    } // Handle the window resize event\n\n  }, {\n    key: \"handleWindowResize\",\n    value: function handleWindowResize() {\n      this.clearTimeout(this.resizeTimeout);\n      this.resizeTimeout = this.setTimeout(this.forceUpdate.bind(this), 100);\n    }\n  }, {\n    key: \"handleZoomInButtonClick\",\n    value: function handleZoomInButtonClick() {\n      var nextZoomLevel = this.state.zoomLevel + ZOOM_BUTTON_INCREMENT_SIZE;\n      this.changeZoom(nextZoomLevel);\n\n      if (nextZoomLevel === MAX_ZOOM_LEVEL) {\n        this.zoomOutBtn.current.focus();\n      }\n    }\n  }, {\n    key: \"handleZoomOutButtonClick\",\n    value: function handleZoomOutButtonClick() {\n      var nextZoomLevel = this.state.zoomLevel - ZOOM_BUTTON_INCREMENT_SIZE;\n      this.changeZoom(nextZoomLevel);\n\n      if (nextZoomLevel === MIN_ZOOM_LEVEL) {\n        this.zoomInBtn.current.focus();\n      }\n    }\n  }, {\n    key: \"handleCaptionMousewheel\",\n    value: function handleCaptionMousewheel(event) {\n      event.stopPropagation();\n\n      if (!this.caption.current) {\n        return;\n      }\n\n      var _this$caption$current = this.caption.current.getBoundingClientRect(),\n          height = _this$caption$current.height;\n\n      var _this$caption$current2 = this.caption.current,\n          scrollHeight = _this$caption$current2.scrollHeight,\n          scrollTop = _this$caption$current2.scrollTop;\n\n      if (event.deltaY > 0 && height + scrollTop >= scrollHeight || event.deltaY < 0 && scrollTop <= 0) {\n        event.preventDefault();\n      }\n    } // Detach key and mouse input events\n\n  }, {\n    key: \"isAnimating\",\n    value: function isAnimating() {\n      return this.state.shouldAnimate || this.state.isClosing;\n    } // Check if image is loaded\n\n  }, {\n    key: \"isImageLoaded\",\n    value: function isImageLoaded(imageSrc) {\n      return imageSrc && imageSrc in this.imageCache && this.imageCache[imageSrc].loaded;\n    } // Load image from src and call callback with image width and height on load\n\n  }, {\n    key: \"loadImage\",\n    value: function loadImage(srcType, imageSrc, done) {\n      var _this13 = this;\n\n      // Return the image info if it is already cached\n      if (this.isImageLoaded(imageSrc)) {\n        this.setTimeout(function () {\n          done();\n        }, 1);\n        return;\n      }\n\n      var inMemoryImage = new global.Image();\n\n      if (this.props.imageCrossOrigin) {\n        inMemoryImage.crossOrigin = this.props.imageCrossOrigin;\n      }\n\n      inMemoryImage.onerror = function (errorEvent) {\n        _this13.props.onImageLoadError(imageSrc, srcType, errorEvent); // failed to load so set the state loadErrorStatus\n\n\n        _this13.setState(function (prevState) {\n          return {\n            loadErrorStatus: _objectSpread2(_objectSpread2({}, prevState.loadErrorStatus), {}, _defineProperty({}, srcType, true))\n          };\n        });\n\n        done(errorEvent);\n      };\n\n      inMemoryImage.onload = function () {\n        _this13.props.onImageLoad(imageSrc, srcType, inMemoryImage);\n\n        _this13.imageCache[imageSrc] = {\n          loaded: true,\n          width: inMemoryImage.width,\n          height: inMemoryImage.height\n        };\n        done();\n      };\n\n      inMemoryImage.src = imageSrc;\n    } // Load all images and their thumbnails\n\n  }, {\n    key: \"loadAllImages\",\n    value: function loadAllImages() {\n      var _this14 = this;\n\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n\n      var generateLoadDoneCallback = function generateLoadDoneCallback(srcType, imageSrc) {\n        return function (err) {\n          // Give up showing image on error\n          if (err) {\n            return;\n          } // Don't rerender if the src is not the same as when the load started\n          // or if the component has unmounted\n\n\n          if (_this14.props[srcType] !== imageSrc || _this14.didUnmount) {\n            return;\n          } // Force rerender with the new image\n\n\n          _this14.forceUpdate();\n        };\n      }; // Load the images\n\n\n      this.getSrcTypes().forEach(function (srcType) {\n        var type = srcType.name; // there is no error when we try to load it initially\n\n        if (props[type] && _this14.state.loadErrorStatus[type]) {\n          _this14.setState(function (prevState) {\n            return {\n              loadErrorStatus: _objectSpread2(_objectSpread2({}, prevState.loadErrorStatus), {}, _defineProperty({}, type, false))\n            };\n          });\n        } // Load unloaded images\n\n\n        if (props[type] && !_this14.isImageLoaded(props[type])) {\n          _this14.loadImage(type, props[type], generateLoadDoneCallback(type, props[type]));\n        }\n      });\n    } // Request that the lightbox be closed\n\n  }, {\n    key: \"requestClose\",\n    value: function requestClose(event) {\n      var _this15 = this;\n\n      // Call the parent close request\n      var closeLightbox = function closeLightbox() {\n        return _this15.props.onCloseRequest(event);\n      };\n\n      if (this.props.animationDisabled || event.type === 'keydown' && !this.props.animationOnKeyInput) {\n        // No animation\n        closeLightbox();\n        return;\n      } // With animation\n      // Start closing animation\n\n\n      this.setState({\n        isClosing: true\n      }); // Perform the actual closing at the end of the animation\n\n      this.setTimeout(closeLightbox, this.props.animationDuration);\n    }\n  }, {\n    key: \"requestMove\",\n    value: function requestMove(direction, event) {\n      var _this16 = this;\n\n      // Reset the zoom level on image move\n      var nextState = {\n        zoomLevel: MIN_ZOOM_LEVEL,\n        offsetX: 0,\n        offsetY: 0\n      }; // Enable animated states\n\n      if (!this.props.animationDisabled && (!this.keyPressed || this.props.animationOnKeyInput)) {\n        nextState.shouldAnimate = true;\n        this.setTimeout(function () {\n          return _this16.setState({\n            shouldAnimate: false\n          });\n        }, this.props.animationDuration);\n      }\n\n      this.keyPressed = false;\n      this.moveRequested = true;\n\n      if (direction === 'prev') {\n        this.keyCounter -= 1;\n        this.setState(nextState);\n        this.props.onMovePrevRequest(event);\n      } else {\n        this.keyCounter += 1;\n        this.setState(nextState);\n        this.props.onMoveNextRequest(event);\n      }\n    } // Request to transition to the next image\n\n  }, {\n    key: \"requestMoveNext\",\n    value: function requestMoveNext(event) {\n      this.requestMove('next', event);\n    } // Request to transition to the previous image\n\n  }, {\n    key: \"requestMovePrev\",\n    value: function requestMovePrev(event) {\n      this.requestMove('prev', event);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this17 = this;\n\n      var _this$props = this.props,\n          animationDisabled = _this$props.animationDisabled,\n          animationDuration = _this$props.animationDuration,\n          clickOutsideToClose = _this$props.clickOutsideToClose,\n          discourageDownloads = _this$props.discourageDownloads,\n          enableZoom = _this$props.enableZoom,\n          imageTitle = _this$props.imageTitle,\n          nextSrc = _this$props.nextSrc,\n          prevSrc = _this$props.prevSrc,\n          toolbarButtons = _this$props.toolbarButtons,\n          reactModalStyle = _this$props.reactModalStyle,\n          _onAfterOpen = _this$props.onAfterOpen,\n          imageCrossOrigin = _this$props.imageCrossOrigin,\n          reactModalProps = _this$props.reactModalProps,\n          loader = _this$props.loader;\n      var _this$state = this.state,\n          zoomLevel = _this$state.zoomLevel,\n          offsetX = _this$state.offsetX,\n          offsetY = _this$state.offsetY,\n          isClosing = _this$state.isClosing,\n          loadErrorStatus = _this$state.loadErrorStatus;\n      var boxSize = this.getLightboxRect();\n      var transitionStyle = {}; // Transition settings for sliding animations\n\n      if (!animationDisabled && this.isAnimating()) {\n        transitionStyle = _objectSpread2(_objectSpread2({}, transitionStyle), {}, {\n          transition: \"transform \".concat(animationDuration, \"ms\")\n        });\n      } // Key endings to differentiate between images with the same src\n\n\n      var keyEndings = {};\n      this.getSrcTypes().forEach(function (_ref12) {\n        var name = _ref12.name,\n            keyEnding = _ref12.keyEnding;\n        keyEndings[name] = keyEnding;\n      }); // Images to be displayed\n\n      var images = [];\n\n      var addImage = function addImage(srcType, imageClass, transforms) {\n        // Ignore types that have no source defined for their full size image\n        if (!_this17.props[srcType]) {\n          return;\n        }\n\n        var bestImageInfo = _this17.getBestImageForType(srcType);\n\n        var imageStyle = _objectSpread2(_objectSpread2({}, transitionStyle), ReactImageLightbox.getTransform(_objectSpread2(_objectSpread2({}, transforms), bestImageInfo)));\n\n        if (zoomLevel > MIN_ZOOM_LEVEL) {\n          imageStyle.cursor = 'move';\n        } // support IE 9 and 11\n\n\n        var hasTrueValue = function hasTrueValue(object) {\n          return Object.keys(object).some(function (key) {\n            return object[key];\n          });\n        }; // when error on one of the loads then push custom error stuff\n\n\n        if (bestImageInfo === null && hasTrueValue(loadErrorStatus)) {\n          images.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n            className: \"\".concat(imageClass, \" ril__image ril-errored\"),\n            style: imageStyle,\n            key: _this17.props[srcType] + keyEndings[srcType]\n          }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n            className: \"ril__errorContainer\"\n          }, _this17.props.imageLoadErrorMessage)));\n          return;\n        }\n\n        if (bestImageInfo === null) {\n          var loadingIcon = loader !== undefined ? loader : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n            className: \"ril-loading-circle ril__loadingCircle ril__loadingContainer__icon\"\n          }, _toConsumableArray(new Array(12)).map(function (_, index) {\n            return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n              // eslint-disable-next-line react/no-array-index-key\n              key: index,\n              className: \"ril-loading-circle-point ril__loadingCirclePoint\"\n            });\n          })); // Fall back to loading icon if the thumbnail has not been loaded\n\n          images.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n            className: \"\".concat(imageClass, \" ril__image ril-not-loaded\"),\n            style: imageStyle,\n            key: _this17.props[srcType] + keyEndings[srcType]\n          }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n            className: \"ril__loadingContainer\"\n          }, loadingIcon)));\n          return;\n        }\n\n        var imageSrc = bestImageInfo.src;\n\n        if (discourageDownloads) {\n          imageStyle.backgroundImage = \"url('\".concat(imageSrc, \"')\");\n          images.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n            className: \"\".concat(imageClass, \" ril__image ril__imageDiscourager\"),\n            onDoubleClick: _this17.handleImageDoubleClick,\n            onWheel: _this17.handleImageMouseWheel,\n            style: imageStyle,\n            key: imageSrc + keyEndings[srcType]\n          }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n            className: \"ril-download-blocker ril__downloadBlocker\"\n          })));\n        } else {\n          images.push( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"img\", _extends({}, imageCrossOrigin ? {\n            crossOrigin: imageCrossOrigin\n          } : {}, {\n            className: \"\".concat(imageClass, \" ril__image\"),\n            onDoubleClick: _this17.handleImageDoubleClick,\n            onWheel: _this17.handleImageMouseWheel,\n            onDragStart: function onDragStart(e) {\n              return e.preventDefault();\n            },\n            style: imageStyle,\n            src: imageSrc,\n            key: imageSrc + keyEndings[srcType],\n            alt: typeof imageTitle === 'string' ? imageTitle : translate('Image'),\n            draggable: false\n          })));\n        }\n      };\n\n      var zoomMultiplier = this.getZoomMultiplier(); // Next Image (displayed on the right)\n\n      addImage('nextSrc', 'ril-image-next ril__imageNext', {\n        x: boxSize.width\n      }); // Main Image\n\n      addImage('mainSrc', 'ril-image-current', {\n        x: -1 * offsetX,\n        y: -1 * offsetY,\n        zoom: zoomMultiplier\n      }); // Previous Image (displayed on the left)\n\n      addImage('prevSrc', 'ril-image-prev ril__imagePrev', {\n        x: -1 * boxSize.width\n      });\n      var modalStyle = {\n        overlay: _objectSpread2({\n          zIndex: 1000,\n          backgroundColor: 'transparent'\n        }, reactModalStyle.overlay),\n        content: _objectSpread2({\n          backgroundColor: 'transparent',\n          overflow: 'hidden',\n          // Needed, otherwise keyboard shortcuts scroll the page\n          border: 'none',\n          borderRadius: 0,\n          padding: 0,\n          top: 0,\n          left: 0,\n          right: 0,\n          bottom: 0\n        }, reactModalStyle.content)\n      };\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react_modal__WEBPACK_IMPORTED_MODULE_1___default()), _extends({\n        isOpen: true,\n        onRequestClose: clickOutsideToClose ? this.requestClose : undefined,\n        onAfterOpen: function onAfterOpen() {\n          // Focus on the div with key handlers\n          if (_this17.outerEl.current) {\n            _this17.outerEl.current.focus();\n          }\n\n          _onAfterOpen();\n        },\n        style: modalStyle,\n        contentLabel: translate('Lightbox'),\n        appElement: typeof global.window !== 'undefined' ? global.window.document.body : undefined\n      }, reactModalProps), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        // eslint-disable-line jsx-a11y/no-static-element-interactions\n        // Floating modal with closing animations\n        className: \"ril-outer ril__outer ril__outerAnimating \".concat(this.props.wrapperClassName, \" \").concat(isClosing ? 'ril-closing ril__outerClosing' : ''),\n        style: {\n          transition: \"opacity \".concat(animationDuration, \"ms\"),\n          animationDuration: \"\".concat(animationDuration, \"ms\"),\n          animationDirection: isClosing ? 'normal' : 'reverse'\n        },\n        ref: this.outerEl,\n        onWheel: this.handleOuterMousewheel,\n        onMouseMove: this.handleMouseMove,\n        onMouseDown: this.handleMouseDown,\n        onTouchStart: this.handleTouchStart,\n        onTouchMove: this.handleTouchMove,\n        tabIndex: \"-1\" // Enables key handlers on div\n        ,\n        onKeyDown: this.handleKeyInput,\n        onKeyUp: this.handleKeyInput\n      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        // eslint-disable-line jsx-a11y/no-static-element-interactions, jsx-a11y/click-events-have-key-events\n        // Image holder\n        className: \"ril-inner ril__inner\",\n        onClick: clickOutsideToClose ? this.closeIfClickInner : undefined\n      }, images), prevSrc && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"button\", {\n        // Move to previous image button\n        type: \"button\",\n        className: \"ril-prev-button ril__navButtons ril__navButtonPrev\",\n        key: \"prev\",\n        \"aria-label\": this.props.prevLabel,\n        title: this.props.prevLabel,\n        onClick: !this.isAnimating() ? this.requestMovePrev : undefined // Ignore clicks during animation\n\n      }), nextSrc && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"button\", {\n        // Move to next image button\n        type: \"button\",\n        className: \"ril-next-button ril__navButtons ril__navButtonNext\",\n        key: \"next\",\n        \"aria-label\": this.props.nextLabel,\n        title: this.props.nextLabel,\n        onClick: !this.isAnimating() ? this.requestMoveNext : undefined // Ignore clicks during animation\n\n      }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        // Lightbox toolbar\n        className: \"ril-toolbar ril__toolbar\"\n      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"ul\", {\n        className: \"ril-toolbar-left ril__toolbarSide ril__toolbarLeftSide\"\n      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"li\", {\n        className: \"ril-toolbar__item ril__toolbarItem\"\n      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"span\", {\n        className: \"ril-toolbar__item__child ril__toolbarItemChild\"\n      }, imageTitle))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"ul\", {\n        className: \"ril-toolbar-right ril__toolbarSide ril__toolbarRightSide\"\n      }, toolbarButtons && toolbarButtons.map(function (button, i) {\n        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"li\", {\n          key: \"button_\".concat(i + 1),\n          className: \"ril-toolbar__item ril__toolbarItem\"\n        }, button);\n      }), enableZoom && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"li\", {\n        className: \"ril-toolbar__item ril__toolbarItem\"\n      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"button\", {\n        // Lightbox zoom in button\n        type: \"button\",\n        key: \"zoom-in\",\n        \"aria-label\": this.props.zoomInLabel,\n        title: this.props.zoomInLabel,\n        className: ['ril-zoom-in', 'ril__toolbarItemChild', 'ril__builtinButton', 'ril__zoomInButton'].concat(_toConsumableArray(zoomLevel === MAX_ZOOM_LEVEL ? ['ril__builtinButtonDisabled'] : [])).join(' '),\n        ref: this.zoomInBtn,\n        disabled: this.isAnimating() || zoomLevel === MAX_ZOOM_LEVEL,\n        onClick: !this.isAnimating() && zoomLevel !== MAX_ZOOM_LEVEL ? this.handleZoomInButtonClick : undefined\n      })), enableZoom && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"li\", {\n        className: \"ril-toolbar__item ril__toolbarItem\"\n      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"button\", {\n        // Lightbox zoom out button\n        type: \"button\",\n        key: \"zoom-out\",\n        \"aria-label\": this.props.zoomOutLabel,\n        title: this.props.zoomOutLabel,\n        className: ['ril-zoom-out', 'ril__toolbarItemChild', 'ril__builtinButton', 'ril__zoomOutButton'].concat(_toConsumableArray(zoomLevel === MIN_ZOOM_LEVEL ? ['ril__builtinButtonDisabled'] : [])).join(' '),\n        ref: this.zoomOutBtn,\n        disabled: this.isAnimating() || zoomLevel === MIN_ZOOM_LEVEL,\n        onClick: !this.isAnimating() && zoomLevel !== MIN_ZOOM_LEVEL ? this.handleZoomOutButtonClick : undefined\n      })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"li\", {\n        className: \"ril-toolbar__item ril__toolbarItem\"\n      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"button\", {\n        // Lightbox close button\n        type: \"button\",\n        key: \"close\",\n        \"aria-label\": this.props.closeLabel,\n        title: this.props.closeLabel,\n        className: \"ril-close ril-toolbar__item__child ril__toolbarItemChild ril__builtinButton ril__closeButton\",\n        onClick: !this.isAnimating() ? this.requestClose : undefined // Ignore clicks during animation\n\n      })))), this.props.imageCaption &&\n      /*#__PURE__*/\n      // eslint-disable-next-line jsx-a11y/no-static-element-interactions\n      react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        // Image caption\n        onWheel: this.handleCaptionMousewheel,\n        onMouseDown: function onMouseDown(event) {\n          return event.stopPropagation();\n        },\n        className: \"ril-caption ril__caption\",\n        ref: this.caption\n      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        className: \"ril-caption-content ril__captionContent\"\n      }, this.props.imageCaption))));\n    }\n  }], [{\n    key: \"isTargetMatchImage\",\n    value: function isTargetMatchImage(target) {\n      return target && /ril-image-current/.test(target.className);\n    }\n  }, {\n    key: \"parseMouseEvent\",\n    value: function parseMouseEvent(mouseEvent) {\n      return {\n        id: 'mouse',\n        source: SOURCE_MOUSE,\n        x: parseInt(mouseEvent.clientX, 10),\n        y: parseInt(mouseEvent.clientY, 10)\n      };\n    }\n  }, {\n    key: \"parseTouchPointer\",\n    value: function parseTouchPointer(touchPointer) {\n      return {\n        id: touchPointer.identifier,\n        source: SOURCE_TOUCH,\n        x: parseInt(touchPointer.clientX, 10),\n        y: parseInt(touchPointer.clientY, 10)\n      };\n    }\n  }, {\n    key: \"parsePointerEvent\",\n    value: function parsePointerEvent(pointerEvent) {\n      return {\n        id: pointerEvent.pointerId,\n        source: SOURCE_POINTER,\n        x: parseInt(pointerEvent.clientX, 10),\n        y: parseInt(pointerEvent.clientY, 10)\n      };\n    } // Request to transition to the previous image\n\n  }, {\n    key: \"getTransform\",\n    value: function getTransform(_ref13) {\n      var _ref13$x = _ref13.x,\n          x = _ref13$x === void 0 ? 0 : _ref13$x,\n          _ref13$y = _ref13.y,\n          y = _ref13$y === void 0 ? 0 : _ref13$y,\n          _ref13$zoom = _ref13.zoom,\n          zoom = _ref13$zoom === void 0 ? 1 : _ref13$zoom,\n          width = _ref13.width,\n          targetWidth = _ref13.targetWidth;\n      var nextX = x;\n      var windowWidth = getWindowWidth();\n\n      if (width > windowWidth) {\n        nextX += (windowWidth - width) / 2;\n      }\n\n      var scaleFactor = zoom * (targetWidth / width);\n      return {\n        transform: \"translate3d(\".concat(nextX, \"px,\").concat(y, \"px,0) scale3d(\").concat(scaleFactor, \",\").concat(scaleFactor, \",1)\")\n      };\n    }\n  }]);\n\n  return ReactImageLightbox;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\n\nReactImageLightbox.propTypes = {\n  //-----------------------------\n  // Image sources\n  //-----------------------------\n  // Main display image url\n  mainSrc: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string).isRequired,\n  // eslint-disable-line react/no-unused-prop-types\n  // Previous display image url (displayed to the left)\n  // If left undefined, movePrev actions will not be performed, and the button not displayed\n  prevSrc: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string),\n  // Next display image url (displayed to the right)\n  // If left undefined, moveNext actions will not be performed, and the button not displayed\n  nextSrc: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string),\n  //-----------------------------\n  // Image thumbnail sources\n  //-----------------------------\n  // Thumbnail image url corresponding to props.mainSrc\n  mainSrcThumbnail: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string),\n  // eslint-disable-line react/no-unused-prop-types\n  // Thumbnail image url corresponding to props.prevSrc\n  prevSrcThumbnail: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string),\n  // eslint-disable-line react/no-unused-prop-types\n  // Thumbnail image url corresponding to props.nextSrc\n  nextSrcThumbnail: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string),\n  // eslint-disable-line react/no-unused-prop-types\n  //-----------------------------\n  // Event Handlers\n  //-----------------------------\n  // Close window event\n  // Should change the parent state such that the lightbox is not rendered\n  onCloseRequest: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func).isRequired,\n  // Move to previous image event\n  // Should change the parent state such that props.prevSrc becomes props.mainSrc,\n  //  props.mainSrc becomes props.nextSrc, etc.\n  onMovePrevRequest: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func),\n  // Move to next image event\n  // Should change the parent state such that props.nextSrc becomes props.mainSrc,\n  //  props.mainSrc becomes props.prevSrc, etc.\n  onMoveNextRequest: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func),\n  // Called when an image fails to load\n  // (imageSrc: string, srcType: string, errorEvent: object): void\n  onImageLoadError: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func),\n  // Called when image successfully loads\n  onImageLoad: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func),\n  // Open window event\n  onAfterOpen: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().func),\n  //-----------------------------\n  // Download discouragement settings\n  //-----------------------------\n  // Enable download discouragement (prevents [right-click -> Save Image As...])\n  discourageDownloads: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),\n  //-----------------------------\n  // Animation settings\n  //-----------------------------\n  // Disable all animation\n  animationDisabled: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),\n  // Disable animation on actions performed with keyboard shortcuts\n  animationOnKeyInput: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),\n  // Animation duration (ms)\n  animationDuration: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number),\n  //-----------------------------\n  // Keyboard shortcut settings\n  //-----------------------------\n  // Required interval of time (ms) between key actions\n  // (prevents excessively fast navigation of images)\n  keyRepeatLimit: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number),\n  // Amount of time (ms) restored after each keyup\n  // (makes rapid key presses slightly faster than holding down the key to navigate images)\n  keyRepeatKeyupBonus: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number),\n  //-----------------------------\n  // Image info\n  //-----------------------------\n  // Image title\n  imageTitle: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().node),\n  // Image caption\n  imageCaption: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().node),\n  // Optional crossOrigin attribute\n  imageCrossOrigin: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string),\n  //-----------------------------\n  // Lightbox style\n  //-----------------------------\n  // Set z-index style, etc., for the parent react-modal (format: https://github.com/reactjs/react-modal#styles )\n  reactModalStyle: prop_types__WEBPACK_IMPORTED_MODULE_2___default().shape({}),\n  // Padding (px) between the edge of the window and the lightbox\n  imagePadding: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().number),\n  wrapperClassName: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string),\n  //-----------------------------\n  // Other\n  //-----------------------------\n  // Array of custom toolbar buttons\n  toolbarButtons: prop_types__WEBPACK_IMPORTED_MODULE_2___default().arrayOf((prop_types__WEBPACK_IMPORTED_MODULE_2___default().node)),\n  // When true, clicks outside of the image close the lightbox\n  clickOutsideToClose: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),\n  // Set to false to disable zoom functionality and hide zoom buttons\n  enableZoom: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().bool),\n  // Override props set on react-modal (https://github.com/reactjs/react-modal)\n  reactModalProps: prop_types__WEBPACK_IMPORTED_MODULE_2___default().shape({}),\n  // Aria-labels\n  nextLabel: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string),\n  prevLabel: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string),\n  zoomInLabel: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string),\n  zoomOutLabel: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string),\n  closeLabel: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().string),\n  imageLoadErrorMessage: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().node),\n  // custom loader\n  loader: (prop_types__WEBPACK_IMPORTED_MODULE_2___default().node)\n};\nReactImageLightbox.defaultProps = {\n  imageTitle: null,\n  imageCaption: null,\n  toolbarButtons: null,\n  reactModalProps: {},\n  animationDisabled: false,\n  animationDuration: 300,\n  animationOnKeyInput: false,\n  clickOutsideToClose: true,\n  closeLabel: 'Close lightbox',\n  discourageDownloads: false,\n  enableZoom: true,\n  imagePadding: 10,\n  imageCrossOrigin: null,\n  keyRepeatKeyupBonus: 40,\n  keyRepeatLimit: 180,\n  mainSrcThumbnail: null,\n  nextLabel: 'Next image',\n  nextSrc: null,\n  nextSrcThumbnail: null,\n  onAfterOpen: function onAfterOpen() {},\n  onImageLoadError: function onImageLoadError() {},\n  onImageLoad: function onImageLoad() {},\n  onMoveNextRequest: function onMoveNextRequest() {},\n  onMovePrevRequest: function onMovePrevRequest() {},\n  prevLabel: 'Previous image',\n  prevSrc: null,\n  prevSrcThumbnail: null,\n  reactModalStyle: {},\n  wrapperClassName: '',\n  zoomInLabel: 'Zoom in',\n  zoomOutLabel: 'Zoom out',\n  imageLoadErrorMessage: 'This image failed to load',\n  loader: undefined\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtMTgtaW1hZ2UtbGlnaHRib3gvZGlzdC9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXlDO0FBQ047QUFDSDs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztB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QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTs7QUFFTixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSLHlGQUF5Rjs7QUFFekY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNFQUFzRTs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTs7QUFFakU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtEQUFrRDtBQUNsRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLFFBQVE7O0FBRWY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUEsR0FB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LGdCQUFnQiwwREFBZ0I7QUFDaEMsY0FBYywwREFBZ0I7QUFDOUIseUJBQXlCLHdEQUFjO0FBQ3ZDO0FBQ0EsVUFBVSx3REFBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxrREFBa0Q7QUFDbEQsd0NBQXdDO0FBQ3hDLG9EQUFvRDtBQUNwRCxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGFydC1hcHAtZGlyLy4vbm9kZV9tb2R1bGVzL3JlYWN0LTE4LWltYWdlLWxpZ2h0Ym94L2Rpc3QvaW5kZXguZXMuanM/NGZhYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBNb2RhbCBmcm9tICdyZWFjdC1tb2RhbCc7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgIGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcblxuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG59XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgdmFyIF9pID0gYXJyID09IG51bGwgPyBudWxsIDogdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdO1xuXG4gIGlmIChfaSA9PSBudWxsKSByZXR1cm47XG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuXG4gIHZhciBfcywgX2U7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbi8qKlxuICogUGxhY2Vob2xkZXIgZm9yIGZ1dHVyZSB0cmFuc2xhdGUgZnVuY3Rpb25hbGl0eVxuICovXG5mdW5jdGlvbiB0cmFuc2xhdGUoc3RyKSB7XG4gIHZhciByZXBsYWNlU3RyaW5ncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcblxuICBpZiAoIXN0cikge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciB0cmFuc2xhdGVkID0gc3RyO1xuXG4gIGlmIChyZXBsYWNlU3RyaW5ncykge1xuICAgIE9iamVjdC5rZXlzKHJlcGxhY2VTdHJpbmdzKS5mb3JFYWNoKGZ1bmN0aW9uIChwbGFjZWhvbGRlcikge1xuICAgICAgdHJhbnNsYXRlZCA9IHRyYW5zbGF0ZWQucmVwbGFjZShwbGFjZWhvbGRlciwgcmVwbGFjZVN0cmluZ3NbcGxhY2Vob2xkZXJdKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0cmFuc2xhdGVkO1xufVxuZnVuY3Rpb24gZ2V0V2luZG93V2lkdGgoKSB7XG4gIHJldHVybiB0eXBlb2YgZ2xvYmFsLndpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwud2luZG93LmlubmVyV2lkdGggOiAwO1xufVxuZnVuY3Rpb24gZ2V0V2luZG93SGVpZ2h0KCkge1xuICByZXR1cm4gdHlwZW9mIGdsb2JhbC53aW5kb3cgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsLndpbmRvdy5pbm5lckhlaWdodCA6IDA7XG59XG5cbnZhciBpc0Nyb3NzT3JpZ2luRnJhbWUgPSBmdW5jdGlvbiBpc0Nyb3NzT3JpZ2luRnJhbWUoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdsb2JhbC53aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgIT09IGdsb2JhbC53aW5kb3cucGFyZW50LmxvY2F0aW9uLmhvc3RuYW1lO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07IC8vIEdldCB0aGUgaGlnaGVzdCB3aW5kb3cgY29udGV4dCB0aGF0IGlzbid0IGNyb3NzLW9yaWdpblxuLy8gKFdoZW4gaW4gYW4gaWZyYW1lKVxuXG5cbmZ1bmN0aW9uIGdldEhpZ2hlc3RTYWZlV2luZG93Q29udGV4dCgpIHtcbiAgdmFyIHNlbGYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGdsb2JhbC53aW5kb3cuc2VsZjtcblxuICAvLyBJZiB3ZSByZWFjaGVkIHRoZSB0b3AgbGV2ZWwsIHJldHVybiBzZWxmXG4gIGlmIChzZWxmID09PSBnbG9iYWwud2luZG93LnRvcCkge1xuICAgIHJldHVybiBzZWxmO1xuICB9IC8vIElmIHBhcmVudCBpcyB0aGUgc2FtZSBvcmlnaW4sIHdlIGNhbiBtb3ZlIHVwIG9uZSBjb250ZXh0XG4gIC8vIFJlZmVyZW5jZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIxOTY1MzQyLzE2MDE5NTNcblxuXG4gIGlmICghaXNDcm9zc09yaWdpbkZyYW1lKCkpIHtcbiAgICByZXR1cm4gZ2V0SGlnaGVzdFNhZmVXaW5kb3dDb250ZXh0KHNlbGYucGFyZW50KTtcbiAgfSAvLyBJZiBhIGRpZmZlcmVudCBvcmlnaW4sIHdlIGNvbnNpZGVyIHRoZSBjdXJyZW50IGxldmVsXG4gIC8vIGFzIHRoZSB0b3AgcmVhY2hhYmxlIG9uZVxuXG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbi8vIE1pbiBpbWFnZSB6b29tIGxldmVsXG52YXIgTUlOX1pPT01fTEVWRUwgPSAwOyAvLyBNYXggaW1hZ2Ugem9vbSBsZXZlbFxuXG52YXIgTUFYX1pPT01fTEVWRUwgPSAzMDA7IC8vIFNpemUgcmF0aW8gYmV0d2VlbiBwcmV2aW91cyBhbmQgbmV4dCB6b29tIGxldmVsc1xuXG52YXIgWk9PTV9SQVRJTyA9IDEuMDA3OyAvLyBIb3cgbXVjaCB0byBpbmNyZWFzZS9kZWNyZWFzZSB0aGUgem9vbSBsZXZlbCB3aGVuIHRoZSB6b29tIGJ1dHRvbnMgYXJlIGNsaWNrZWRcblxudmFyIFpPT01fQlVUVE9OX0lOQ1JFTUVOVF9TSVpFID0gMTAwOyAvLyBVc2VkIHRvIGp1ZGdlIHRoZSBhbW91bnQgb2YgaG9yaXpvbnRhbCBzY3JvbGwgbmVlZGVkIHRvIGluaXRpYXRlIGEgaW1hZ2UgbW92ZVxuXG52YXIgV0hFRUxfTU9WRV9YX1RIUkVTSE9MRCA9IDIwMDsgLy8gVXNlZCB0byBqdWRnZSB0aGUgYW1vdW50IG9mIHZlcnRpY2FsIHNjcm9sbCBuZWVkZWQgdG8gaW5pdGlhdGUgYSB6b29tIGFjdGlvblxuXG52YXIgV0hFRUxfTU9WRV9ZX1RIUkVTSE9MRCA9IDE7XG52YXIgS0VZUyA9IHtcbiAgRVNDOiAyNyxcbiAgTEVGVF9BUlJPVzogMzcsXG4gIFJJR0hUX0FSUk9XOiAzOVxufTsgLy8gQWN0aW9uc1xuXG52YXIgQUNUSU9OX05PTkUgPSAwO1xudmFyIEFDVElPTl9NT1ZFID0gMTtcbnZhciBBQ1RJT05fU1dJUEUgPSAyO1xudmFyIEFDVElPTl9QSU5DSCA9IDM7XG5cbnZhciBTT1VSQ0VfQU5ZID0gMDtcbnZhciBTT1VSQ0VfTU9VU0UgPSAxO1xudmFyIFNPVVJDRV9UT1VDSCA9IDI7XG52YXIgU09VUkNFX1BPSU5URVIgPSAzOyAvLyBNaW5pbWFsIHN3aXBlIGRpc3RhbmNlXG5cbnZhciBNSU5fU1dJUEVfRElTVEFOQ0UgPSAyMDA7XG5cbnZhciBSZWFjdEltYWdlTGlnaHRib3ggPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFJlYWN0SW1hZ2VMaWdodGJveCwgX0NvbXBvbmVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihSZWFjdEltYWdlTGlnaHRib3gpO1xuXG4gIGZ1bmN0aW9uIFJlYWN0SW1hZ2VMaWdodGJveChwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWFjdEltYWdlTGlnaHRib3gpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcyk7XG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBBbmltYXRpb25cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIExpZ2h0Ym94IGlzIGNsb3NpbmdcbiAgICAgIC8vIFdoZW4gTGlnaHRib3ggaXMgbW91bnRlZCwgaWYgYW5pbWF0aW9uIGlzIGVuYWJsZWQgaXQgd2lsbCBvcGVuIHdpdGggdGhlIHJldmVyc2Ugb2YgdGhlIGNsb3NpbmcgYW5pbWF0aW9uXG4gICAgICBpc0Nsb3Npbmc6ICFwcm9wcy5hbmltYXRpb25EaXNhYmxlZCxcbiAgICAgIC8vIENvbXBvbmVudCBwYXJ0cyBzaG91bGQgYW5pbWF0ZSAoZS5nLiwgd2hlbiBpbWFnZXMgYXJlIG1vdmluZywgb3IgaW1hZ2UgaXMgYmVpbmcgem9vbWVkKVxuICAgICAgc2hvdWxkQW5pbWF0ZTogZmFsc2UsXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBab29tIHNldHRpbmdzXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBab29tIGxldmVsIG9mIGltYWdlXG4gICAgICB6b29tTGV2ZWw6IE1JTl9aT09NX0xFVkVMLFxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gSW1hZ2UgcG9zaXRpb24gc2V0dGluZ3NcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIEhvcml6b250YWwgb2Zmc2V0IGZyb20gY2VudGVyXG4gICAgICBvZmZzZXRYOiAwLFxuICAgICAgLy8gVmVydGljYWwgb2Zmc2V0IGZyb20gY2VudGVyXG4gICAgICBvZmZzZXRZOiAwLFxuICAgICAgLy8gaW1hZ2UgbG9hZCBlcnJvciBmb3Igc3JjVHlwZVxuICAgICAgbG9hZEVycm9yU3RhdHVzOiB7fVxuICAgIH07IC8vIFJlZnNcblxuICAgIF90aGlzLm91dGVyRWwgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgX3RoaXMuem9vbUluQnRuID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZVJlZigpO1xuICAgIF90aGlzLnpvb21PdXRCdG4gPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgX3RoaXMuY2FwdGlvbiA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVSZWYoKTtcbiAgICBfdGhpcy5jbG9zZUlmQ2xpY2tJbm5lciA9IF90aGlzLmNsb3NlSWZDbGlja0lubmVyLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLmhhbmRsZUltYWdlRG91YmxlQ2xpY2sgPSBfdGhpcy5oYW5kbGVJbWFnZURvdWJsZUNsaWNrLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLmhhbmRsZUltYWdlTW91c2VXaGVlbCA9IF90aGlzLmhhbmRsZUltYWdlTW91c2VXaGVlbC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5oYW5kbGVLZXlJbnB1dCA9IF90aGlzLmhhbmRsZUtleUlucHV0LmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLmhhbmRsZU1vdXNlVXAgPSBfdGhpcy5oYW5kbGVNb3VzZVVwLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLmhhbmRsZU1vdXNlRG93biA9IF90aGlzLmhhbmRsZU1vdXNlRG93bi5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5oYW5kbGVNb3VzZU1vdmUgPSBfdGhpcy5oYW5kbGVNb3VzZU1vdmUuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMuaGFuZGxlT3V0ZXJNb3VzZXdoZWVsID0gX3RoaXMuaGFuZGxlT3V0ZXJNb3VzZXdoZWVsLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLmhhbmRsZVRvdWNoU3RhcnQgPSBfdGhpcy5oYW5kbGVUb3VjaFN0YXJ0LmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLmhhbmRsZVRvdWNoTW92ZSA9IF90aGlzLmhhbmRsZVRvdWNoTW92ZS5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5oYW5kbGVUb3VjaEVuZCA9IF90aGlzLmhhbmRsZVRvdWNoRW5kLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLmhhbmRsZVBvaW50ZXJFdmVudCA9IF90aGlzLmhhbmRsZVBvaW50ZXJFdmVudC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5oYW5kbGVDYXB0aW9uTW91c2V3aGVlbCA9IF90aGlzLmhhbmRsZUNhcHRpb25Nb3VzZXdoZWVsLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLmhhbmRsZVdpbmRvd1Jlc2l6ZSA9IF90aGlzLmhhbmRsZVdpbmRvd1Jlc2l6ZS5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5oYW5kbGVab29tSW5CdXR0b25DbGljayA9IF90aGlzLmhhbmRsZVpvb21JbkJ1dHRvbkNsaWNrLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLmhhbmRsZVpvb21PdXRCdXR0b25DbGljayA9IF90aGlzLmhhbmRsZVpvb21PdXRCdXR0b25DbGljay5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5yZXF1ZXN0Q2xvc2UgPSBfdGhpcy5yZXF1ZXN0Q2xvc2UuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMucmVxdWVzdE1vdmVOZXh0ID0gX3RoaXMucmVxdWVzdE1vdmVOZXh0LmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLnJlcXVlc3RNb3ZlUHJldiA9IF90aGlzLnJlcXVlc3RNb3ZlUHJldi5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTsgLy8gVGltZW91dHMgLSBhbHdheXMgY2xlYXIgaXQgYmVmb3JlIHVtb3VudFxuXG4gICAgX3RoaXMudGltZW91dHMgPSBbXTsgLy8gQ3VycmVudCBhY3Rpb25cblxuICAgIF90aGlzLmN1cnJlbnRBY3Rpb24gPSBBQ1RJT05fTk9ORTsgLy8gRXZlbnRzIHNvdXJjZVxuXG4gICAgX3RoaXMuZXZlbnRzU291cmNlID0gU09VUkNFX0FOWTsgLy8gRW1wdHkgcG9pbnRlcnMgbGlzdFxuXG4gICAgX3RoaXMucG9pbnRlckxpc3QgPSBbXTsgLy8gUHJldmVudCBpbm5lciBjbG9zZVxuXG4gICAgX3RoaXMucHJldmVudElubmVyQ2xvc2UgPSBmYWxzZTtcbiAgICBfdGhpcy5wcmV2ZW50SW5uZXJDbG9zZVRpbWVvdXQgPSBudWxsOyAvLyBVc2VkIHRvIGRpc2FibGUgYW5pbWF0aW9uIHdoZW4gY2hhbmdpbmcgcHJvcHMubWFpblNyY3xuZXh0U3JjfHByZXZTcmNcblxuICAgIF90aGlzLmtleVByZXNzZWQgPSBmYWxzZTsgLy8gVXNlZCB0byBzdG9yZSBsb2FkIHN0YXRlIC8gZGltZW5zaW9ucyBvZiBpbWFnZXNcblxuICAgIF90aGlzLmltYWdlQ2FjaGUgPSB7fTsgLy8gVGltZSB0aGUgbGFzdCBrZXlkb3duIGV2ZW50IHdhcyBjYWxsZWQgKHVzZWQgaW4ga2V5Ym9hcmQgYWN0aW9uIHJhdGUgbGltaXRpbmcpXG5cbiAgICBfdGhpcy5sYXN0S2V5RG93blRpbWUgPSAwOyAvLyBVc2VkIGZvciBkZWJvdW5jaW5nIHdpbmRvdyByZXNpemUgZXZlbnRcblxuICAgIF90aGlzLnJlc2l6ZVRpbWVvdXQgPSBudWxsOyAvLyBVc2VkIHRvIGRldGVybWluZSB3aGVuIGFjdGlvbnMgYXJlIHRyaWdnZXJlZCBieSB0aGUgc2Nyb2xsIHdoZWVsXG5cbiAgICBfdGhpcy53aGVlbEFjdGlvblRpbWVvdXQgPSBudWxsO1xuICAgIF90aGlzLnJlc2V0U2Nyb2xsVGltZW91dCA9IG51bGw7XG4gICAgX3RoaXMuc2Nyb2xsWCA9IDA7XG4gICAgX3RoaXMuc2Nyb2xsWSA9IDA7IC8vIFVzZWQgaW4gcGFubmluZyB6b29tZWQgaW1hZ2VzXG5cbiAgICBfdGhpcy5tb3ZlU3RhcnRYID0gMDtcbiAgICBfdGhpcy5tb3ZlU3RhcnRZID0gMDtcbiAgICBfdGhpcy5tb3ZlU3RhcnRPZmZzZXRYID0gMDtcbiAgICBfdGhpcy5tb3ZlU3RhcnRPZmZzZXRZID0gMDsgLy8gVXNlZCB0byBzd2lwZVxuXG4gICAgX3RoaXMuc3dpcGVTdGFydFggPSAwO1xuICAgIF90aGlzLnN3aXBlU3RhcnRZID0gMDtcbiAgICBfdGhpcy5zd2lwZUVuZFggPSAwO1xuICAgIF90aGlzLnN3aXBlRW5kWSA9IDA7IC8vIFVzZWQgdG8gcGluY2hcblxuICAgIF90aGlzLnBpbmNoVG91Y2hMaXN0ID0gbnVsbDtcbiAgICBfdGhpcy5waW5jaERpc3RhbmNlID0gMDsgLy8gVXNlZCB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gaW1hZ2VzIHdpdGggaWRlbnRpY2FsIHNyY1xuXG4gICAgX3RoaXMua2V5Q291bnRlciA9IDA7IC8vIFVzZWQgdG8gZGV0ZWN0IGEgbW92ZSB3aGVuIGFsbCBzcmMncyByZW1haW4gdW5jaGFuZ2VkIChmb3VyIG9yIG1vcmUgb2YgdGhlIHNhbWUgaW1hZ2UgaW4gYSByb3cpXG5cbiAgICBfdGhpcy5tb3ZlUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFJlYWN0SW1hZ2VMaWdodGJveCwgW3tcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkTW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLnByb3BzLmFuaW1hdGlvbkRpc2FibGVkKSB7XG4gICAgICAgIC8vIE1ha2Ugb3BlbmluZyBhbmltYXRpb24gcGxheVxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBpc0Nsb3Npbmc6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBQcmV2ZW50cyBjcm9zcy1vcmlnaW4gZXJyb3JzIHdoZW4gdXNpbmcgYSBjcm9zcy1vcmlnaW4gaWZyYW1lXG5cblxuICAgICAgdGhpcy53aW5kb3dDb250ZXh0ID0gZ2V0SGlnaGVzdFNhZmVXaW5kb3dDb250ZXh0KCk7XG4gICAgICB0aGlzLmxpc3RlbmVycyA9IHtcbiAgICAgICAgcmVzaXplOiB0aGlzLmhhbmRsZVdpbmRvd1Jlc2l6ZSxcbiAgICAgICAgbW91c2V1cDogdGhpcy5oYW5kbGVNb3VzZVVwLFxuICAgICAgICB0b3VjaGVuZDogdGhpcy5oYW5kbGVUb3VjaEVuZCxcbiAgICAgICAgdG91Y2hjYW5jZWw6IHRoaXMuaGFuZGxlVG91Y2hFbmQsXG4gICAgICAgIHBvaW50ZXJkb3duOiB0aGlzLmhhbmRsZVBvaW50ZXJFdmVudCxcbiAgICAgICAgcG9pbnRlcm1vdmU6IHRoaXMuaGFuZGxlUG9pbnRlckV2ZW50LFxuICAgICAgICBwb2ludGVydXA6IHRoaXMuaGFuZGxlUG9pbnRlckV2ZW50LFxuICAgICAgICBwb2ludGVyY2FuY2VsOiB0aGlzLmhhbmRsZVBvaW50ZXJFdmVudFxuICAgICAgfTtcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMubGlzdGVuZXJzKS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIF90aGlzMi53aW5kb3dDb250ZXh0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgX3RoaXMyLmxpc3RlbmVyc1t0eXBlXSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubG9hZEFsbEltYWdlcygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaG91bGRDb21wb25lbnRVcGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcykge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuZ2V0U3JjVHlwZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChzcmNUeXBlKSB7XG4gICAgICAgIGlmIChfdGhpczMucHJvcHNbc3JjVHlwZS5uYW1lXSAhPT0gbmV4dFByb3BzW3NyY1R5cGUubmFtZV0pIHtcbiAgICAgICAgICBfdGhpczMubW92ZVJlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTsgLy8gV2FpdCBmb3IgbW92ZS4uLlxuXG4gICAgICByZXR1cm4gIXRoaXMubW92ZVJlcXVlc3RlZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgc291cmNlc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgIHZhciBwcmV2U3JjRGljdCA9IHt9O1xuICAgICAgdmFyIG5leHRTcmNEaWN0ID0ge307XG4gICAgICB0aGlzLmdldFNyY1R5cGVzKCkuZm9yRWFjaChmdW5jdGlvbiAoc3JjVHlwZSkge1xuICAgICAgICBpZiAocHJldlByb3BzW3NyY1R5cGUubmFtZV0gIT09IF90aGlzNC5wcm9wc1tzcmNUeXBlLm5hbWVdKSB7XG4gICAgICAgICAgc291cmNlc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIHByZXZTcmNEaWN0W3ByZXZQcm9wc1tzcmNUeXBlLm5hbWVdXSA9IHRydWU7XG4gICAgICAgICAgbmV4dFNyY0RpY3RbX3RoaXM0LnByb3BzW3NyY1R5cGUubmFtZV1dID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChzb3VyY2VzQ2hhbmdlZCB8fCB0aGlzLm1vdmVSZXF1ZXN0ZWQpIHtcbiAgICAgICAgLy8gUmVzZXQgdGhlIGxvYWRlZCBzdGF0ZSBmb3IgaW1hZ2VzIG5vdCByZW5kZXJlZCBuZXh0XG4gICAgICAgIE9iamVjdC5rZXlzKHByZXZTcmNEaWN0KS5mb3JFYWNoKGZ1bmN0aW9uIChwcmV2U3JjKSB7XG4gICAgICAgICAgaWYgKCEocHJldlNyYyBpbiBuZXh0U3JjRGljdCkgJiYgcHJldlNyYyBpbiBfdGhpczQuaW1hZ2VDYWNoZSkge1xuICAgICAgICAgICAgX3RoaXM0LmltYWdlQ2FjaGVbcHJldlNyY10ubG9hZGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tb3ZlUmVxdWVzdGVkID0gZmFsc2U7IC8vIExvYWQgYW55IG5ldyBpbWFnZXNcblxuICAgICAgICB0aGlzLmxvYWRBbGxJbWFnZXModGhpcy5wcm9wcyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHRoaXMuZGlkVW5tb3VudCA9IHRydWU7XG4gICAgICBPYmplY3Qua2V5cyh0aGlzLmxpc3RlbmVycykuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBfdGhpczUud2luZG93Q29udGV4dC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIF90aGlzNS5saXN0ZW5lcnNbdHlwZV0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnRpbWVvdXRzLmZvckVhY2goZnVuY3Rpb24gKHRpZCkge1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KHRpZCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VGltZW91dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoX3NldFRpbWVvdXQpIHtcbiAgICAgIGZ1bmN0aW9uIHNldFRpbWVvdXQoX3gsIF94Mikge1xuICAgICAgICByZXR1cm4gX3NldFRpbWVvdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgc2V0VGltZW91dC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zZXRUaW1lb3V0LnRvU3RyaW5nKCk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gc2V0VGltZW91dDtcbiAgICB9KGZ1bmN0aW9uIChmdW5jLCB0aW1lKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgdmFyIGlkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNi50aW1lb3V0cyA9IF90aGlzNi50aW1lb3V0cy5maWx0ZXIoZnVuY3Rpb24gKHRpZCkge1xuICAgICAgICAgIHJldHVybiB0aWQgIT09IGlkO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuYygpO1xuICAgICAgfSwgdGltZSk7XG4gICAgICB0aGlzLnRpbWVvdXRzLnB1c2goaWQpO1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH0pXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UHJldmVudElubmVyQ2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UHJldmVudElubmVyQ2xvc2UoKSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMucHJldmVudElubmVyQ2xvc2VUaW1lb3V0KSB7XG4gICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KHRoaXMucHJldmVudElubmVyQ2xvc2VUaW1lb3V0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcmV2ZW50SW5uZXJDbG9zZSA9IHRydWU7XG4gICAgICB0aGlzLnByZXZlbnRJbm5lckNsb3NlVGltZW91dCA9IHRoaXMuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNy5wcmV2ZW50SW5uZXJDbG9zZSA9IGZhbHNlO1xuICAgICAgICBfdGhpczcucHJldmVudElubmVyQ2xvc2VUaW1lb3V0ID0gbnVsbDtcbiAgICAgIH0sIDEwMCk7XG4gICAgfSAvLyBHZXQgaW5mbyBmb3IgdGhlIGJlc3Qgc3VpdGVkIGltYWdlIHRvIGRpc3BsYXkgd2l0aCB0aGUgZ2l2ZW4gc3JjVHlwZVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QmVzdEltYWdlRm9yVHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCZXN0SW1hZ2VGb3JUeXBlKHNyY1R5cGUpIHtcbiAgICAgIHZhciBpbWFnZVNyYyA9IHRoaXMucHJvcHNbc3JjVHlwZV07XG4gICAgICB2YXIgZml0U2l6ZXMgPSB7fTtcblxuICAgICAgaWYgKHRoaXMuaXNJbWFnZUxvYWRlZChpbWFnZVNyYykpIHtcbiAgICAgICAgLy8gVXNlIGZ1bGwtc2l6ZSBpbWFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgZml0U2l6ZXMgPSB0aGlzLmdldEZpdFNpemVzKHRoaXMuaW1hZ2VDYWNoZVtpbWFnZVNyY10ud2lkdGgsIHRoaXMuaW1hZ2VDYWNoZVtpbWFnZVNyY10uaGVpZ2h0KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0ltYWdlTG9hZGVkKHRoaXMucHJvcHNbXCJcIi5jb25jYXQoc3JjVHlwZSwgXCJUaHVtYm5haWxcIildKSkge1xuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gdXNpbmcgdGh1bWJuYWlsIGlmIHRoZSBpbWFnZSBoYXMgbm90IGJlZW4gbG9hZGVkXG4gICAgICAgIGltYWdlU3JjID0gdGhpcy5wcm9wc1tcIlwiLmNvbmNhdChzcmNUeXBlLCBcIlRodW1ibmFpbFwiKV07XG4gICAgICAgIGZpdFNpemVzID0gdGhpcy5nZXRGaXRTaXplcyh0aGlzLmltYWdlQ2FjaGVbaW1hZ2VTcmNdLndpZHRoLCB0aGlzLmltYWdlQ2FjaGVbaW1hZ2VTcmNdLmhlaWdodCwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3JjOiBpbWFnZVNyYyxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmltYWdlQ2FjaGVbaW1hZ2VTcmNdLmhlaWdodCxcbiAgICAgICAgd2lkdGg6IHRoaXMuaW1hZ2VDYWNoZVtpbWFnZVNyY10ud2lkdGgsXG4gICAgICAgIHRhcmdldEhlaWdodDogZml0U2l6ZXMuaGVpZ2h0LFxuICAgICAgICB0YXJnZXRXaWR0aDogZml0U2l6ZXMud2lkdGhcbiAgICAgIH07XG4gICAgfSAvLyBHZXQgc2l6aW5nIGZvciB3aGVuIGFuIGltYWdlIGlzIGxhcmdlciB0aGFuIHRoZSB3aW5kb3dcblxuICB9LCB7XG4gICAga2V5OiBcImdldEZpdFNpemVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZpdFNpemVzKHdpZHRoLCBoZWlnaHQsIHN0cmV0Y2gpIHtcbiAgICAgIHZhciBib3hTaXplID0gdGhpcy5nZXRMaWdodGJveFJlY3QoKTtcbiAgICAgIHZhciBtYXhIZWlnaHQgPSBib3hTaXplLmhlaWdodCAtIHRoaXMucHJvcHMuaW1hZ2VQYWRkaW5nICogMjtcbiAgICAgIHZhciBtYXhXaWR0aCA9IGJveFNpemUud2lkdGggLSB0aGlzLnByb3BzLmltYWdlUGFkZGluZyAqIDI7XG5cbiAgICAgIGlmICghc3RyZXRjaCkge1xuICAgICAgICBtYXhIZWlnaHQgPSBNYXRoLm1pbihtYXhIZWlnaHQsIGhlaWdodCk7XG4gICAgICAgIG1heFdpZHRoID0gTWF0aC5taW4obWF4V2lkdGgsIHdpZHRoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1heFJhdGlvID0gbWF4V2lkdGggLyBtYXhIZWlnaHQ7XG4gICAgICB2YXIgc3JjUmF0aW8gPSB3aWR0aCAvIGhlaWdodDtcblxuICAgICAgaWYgKG1heFJhdGlvID4gc3JjUmF0aW8pIHtcbiAgICAgICAgLy8gaGVpZ2h0IGlzIHRoZSBjb25zdHJhaW5pbmcgZGltZW5zaW9uIG9mIHRoZSBwaG90b1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHdpZHRoOiB3aWR0aCAqIG1heEhlaWdodCAvIGhlaWdodCxcbiAgICAgICAgICBoZWlnaHQ6IG1heEhlaWdodFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogbWF4V2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0ICogbWF4V2lkdGggLyB3aWR0aFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWF4T2Zmc2V0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNYXhPZmZzZXRzKCkge1xuICAgICAgdmFyIHpvb21MZXZlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5zdGF0ZS56b29tTGV2ZWw7XG4gICAgICB2YXIgY3VycmVudEltYWdlSW5mbyA9IHRoaXMuZ2V0QmVzdEltYWdlRm9yVHlwZSgnbWFpblNyYycpO1xuXG4gICAgICBpZiAoY3VycmVudEltYWdlSW5mbyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1heFg6IDAsXG4gICAgICAgICAgbWluWDogMCxcbiAgICAgICAgICBtYXhZOiAwLFxuICAgICAgICAgIG1pblk6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJveFNpemUgPSB0aGlzLmdldExpZ2h0Ym94UmVjdCgpO1xuICAgICAgdmFyIHpvb21NdWx0aXBsaWVyID0gdGhpcy5nZXRab29tTXVsdGlwbGllcih6b29tTGV2ZWwpO1xuICAgICAgdmFyIG1heFggPSAwO1xuXG4gICAgICBpZiAoem9vbU11bHRpcGxpZXIgKiBjdXJyZW50SW1hZ2VJbmZvLndpZHRoIC0gYm94U2l6ZS53aWR0aCA8IDApIHtcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgc3RpbGwgYmxhbmsgc3BhY2UgaW4gdGhlIFggZGltZW5zaW9uLCBkb24ndCBsaW1pdCBleGNlcHQgdG8gdGhlIG9wcG9zaXRlIGVkZ2VcbiAgICAgICAgbWF4WCA9IChib3hTaXplLndpZHRoIC0gem9vbU11bHRpcGxpZXIgKiBjdXJyZW50SW1hZ2VJbmZvLndpZHRoKSAvIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXhYID0gKHpvb21NdWx0aXBsaWVyICogY3VycmVudEltYWdlSW5mby53aWR0aCAtIGJveFNpemUud2lkdGgpIC8gMjtcbiAgICAgIH1cblxuICAgICAgdmFyIG1heFkgPSAwO1xuXG4gICAgICBpZiAoem9vbU11bHRpcGxpZXIgKiBjdXJyZW50SW1hZ2VJbmZvLmhlaWdodCAtIGJveFNpemUuaGVpZ2h0IDwgMCkge1xuICAgICAgICAvLyBpZiB0aGVyZSBpcyBzdGlsbCBibGFuayBzcGFjZSBpbiB0aGUgWSBkaW1lbnNpb24sIGRvbid0IGxpbWl0IGV4Y2VwdCB0byB0aGUgb3Bwb3NpdGUgZWRnZVxuICAgICAgICBtYXhZID0gKGJveFNpemUuaGVpZ2h0IC0gem9vbU11bHRpcGxpZXIgKiBjdXJyZW50SW1hZ2VJbmZvLmhlaWdodCkgLyAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF4WSA9ICh6b29tTXVsdGlwbGllciAqIGN1cnJlbnRJbWFnZUluZm8uaGVpZ2h0IC0gYm94U2l6ZS5oZWlnaHQpIC8gMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWF4WDogbWF4WCxcbiAgICAgICAgbWF4WTogbWF4WSxcbiAgICAgICAgbWluWDogLTEgKiBtYXhYLFxuICAgICAgICBtaW5ZOiAtMSAqIG1heFlcbiAgICAgIH07XG4gICAgfSAvLyBHZXQgaW1hZ2Ugc3JjIHR5cGVzXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRTcmNUeXBlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTcmNUeXBlcygpIHtcbiAgICAgIHJldHVybiBbe1xuICAgICAgICBuYW1lOiAnbWFpblNyYycsXG4gICAgICAgIGtleUVuZGluZzogXCJpXCIuY29uY2F0KHRoaXMua2V5Q291bnRlcilcbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogJ21haW5TcmNUaHVtYm5haWwnLFxuICAgICAgICBrZXlFbmRpbmc6IFwidFwiLmNvbmNhdCh0aGlzLmtleUNvdW50ZXIpXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICduZXh0U3JjJyxcbiAgICAgICAga2V5RW5kaW5nOiBcImlcIi5jb25jYXQodGhpcy5rZXlDb3VudGVyICsgMSlcbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogJ25leHRTcmNUaHVtYm5haWwnLFxuICAgICAgICBrZXlFbmRpbmc6IFwidFwiLmNvbmNhdCh0aGlzLmtleUNvdW50ZXIgKyAxKVxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAncHJldlNyYycsXG4gICAgICAgIGtleUVuZGluZzogXCJpXCIuY29uY2F0KHRoaXMua2V5Q291bnRlciAtIDEpXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdwcmV2U3JjVGh1bWJuYWlsJyxcbiAgICAgICAga2V5RW5kaW5nOiBcInRcIi5jb25jYXQodGhpcy5rZXlDb3VudGVyIC0gMSlcbiAgICAgIH1dO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgc2l6aW5nIHdoZW4gdGhlIGltYWdlIGlzIHNjYWxlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Wm9vbU11bHRpcGxpZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Wm9vbU11bHRpcGxpZXIoKSB7XG4gICAgICB2YXIgem9vbUxldmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLnN0YXRlLnpvb21MZXZlbDtcbiAgICAgIHJldHVybiBNYXRoLnBvdyhaT09NX1JBVElPLCB6b29tTGV2ZWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHNpemUgb2YgdGhlIGxpZ2h0Ym94IGluIHBpeGVsc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TGlnaHRib3hSZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExpZ2h0Ym94UmVjdCgpIHtcbiAgICAgIGlmICh0aGlzLm91dGVyRWwuY3VycmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vdXRlckVsLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBnZXRXaW5kb3dXaWR0aCgpLFxuICAgICAgICBoZWlnaHQ6IGdldFdpbmRvd0hlaWdodCgpLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICBib3R0b206IDAsXG4gICAgICAgIGxlZnQ6IDBcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyVGltZW91dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoX2NsZWFyVGltZW91dCkge1xuICAgICAgZnVuY3Rpb24gY2xlYXJUaW1lb3V0KF94Mykge1xuICAgICAgICByZXR1cm4gX2NsZWFyVGltZW91dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICBjbGVhclRpbWVvdXQudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfY2xlYXJUaW1lb3V0LnRvU3RyaW5nKCk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gY2xlYXJUaW1lb3V0O1xuICAgIH0oZnVuY3Rpb24gKGlkKSB7XG4gICAgICB0aGlzLnRpbWVvdXRzID0gdGhpcy50aW1lb3V0cy5maWx0ZXIoZnVuY3Rpb24gKHRpZCkge1xuICAgICAgICByZXR1cm4gdGlkICE9PSBpZDtcbiAgICAgIH0pO1xuICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICB9IC8vIENoYW5nZSB6b29tIGxldmVsXG4gICAgKVxuICB9LCB7XG4gICAga2V5OiBcImNoYW5nZVpvb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hhbmdlWm9vbSh6b29tTGV2ZWwsIGNsaWVudFgsIGNsaWVudFkpIHtcbiAgICAgIC8vIElnbm9yZSBpZiB6b29tIGRpc2FibGVkXG4gICAgICBpZiAoIXRoaXMucHJvcHMuZW5hYmxlWm9vbSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIENvbnN0cmFpbiB6b29tIGxldmVsIHRvIHRoZSBzZXQgYm91bmRzXG5cblxuICAgICAgdmFyIG5leHRab29tTGV2ZWwgPSBNYXRoLm1heChNSU5fWk9PTV9MRVZFTCwgTWF0aC5taW4oTUFYX1pPT01fTEVWRUwsIHpvb21MZXZlbCkpOyAvLyBJZ25vcmUgcmVxdWVzdHMgdGhhdCBkb24ndCBjaGFuZ2UgdGhlIHpvb20gbGV2ZWxcblxuICAgICAgaWYgKG5leHRab29tTGV2ZWwgPT09IHRoaXMuc3RhdGUuem9vbUxldmVsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG5leHRab29tTGV2ZWwgPT09IE1JTl9aT09NX0xFVkVMKSB7XG4gICAgICAgIC8vIFNuYXAgYmFjayB0byBjZW50ZXIgaWYgem9vbWVkIGFsbCB0aGUgd2F5IG91dFxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICB6b29tTGV2ZWw6IG5leHRab29tTGV2ZWwsXG4gICAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgICBvZmZzZXRZOiAwXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpbWFnZUJhc2VTaXplID0gdGhpcy5nZXRCZXN0SW1hZ2VGb3JUeXBlKCdtYWluU3JjJyk7XG5cbiAgICAgIGlmIChpbWFnZUJhc2VTaXplID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnJlbnRab29tTXVsdGlwbGllciA9IHRoaXMuZ2V0Wm9vbU11bHRpcGxpZXIoKTtcbiAgICAgIHZhciBuZXh0Wm9vbU11bHRpcGxpZXIgPSB0aGlzLmdldFpvb21NdWx0aXBsaWVyKG5leHRab29tTGV2ZWwpOyAvLyBEZWZhdWx0IHRvIHRoZSBjZW50ZXIgb2YgdGhlIGltYWdlIHRvIHpvb20gd2hlbiBubyBtb3VzZSBwb3NpdGlvbiBzcGVjaWZpZWRcblxuICAgICAgdmFyIGJveFJlY3QgPSB0aGlzLmdldExpZ2h0Ym94UmVjdCgpO1xuICAgICAgdmFyIHBvaW50ZXJYID0gdHlwZW9mIGNsaWVudFggIT09ICd1bmRlZmluZWQnID8gY2xpZW50WCAtIGJveFJlY3QubGVmdCA6IGJveFJlY3Qud2lkdGggLyAyO1xuICAgICAgdmFyIHBvaW50ZXJZID0gdHlwZW9mIGNsaWVudFkgIT09ICd1bmRlZmluZWQnID8gY2xpZW50WSAtIGJveFJlY3QudG9wIDogYm94UmVjdC5oZWlnaHQgLyAyO1xuICAgICAgdmFyIGN1cnJlbnRJbWFnZU9mZnNldFggPSAoYm94UmVjdC53aWR0aCAtIGltYWdlQmFzZVNpemUud2lkdGggKiBjdXJyZW50Wm9vbU11bHRpcGxpZXIpIC8gMjtcbiAgICAgIHZhciBjdXJyZW50SW1hZ2VPZmZzZXRZID0gKGJveFJlY3QuaGVpZ2h0IC0gaW1hZ2VCYXNlU2l6ZS5oZWlnaHQgKiBjdXJyZW50Wm9vbU11bHRpcGxpZXIpIC8gMjtcbiAgICAgIHZhciBjdXJyZW50SW1hZ2VSZWFsT2Zmc2V0WCA9IGN1cnJlbnRJbWFnZU9mZnNldFggLSB0aGlzLnN0YXRlLm9mZnNldFg7XG4gICAgICB2YXIgY3VycmVudEltYWdlUmVhbE9mZnNldFkgPSBjdXJyZW50SW1hZ2VPZmZzZXRZIC0gdGhpcy5zdGF0ZS5vZmZzZXRZO1xuICAgICAgdmFyIGN1cnJlbnRQb2ludGVyWFJlbGF0aXZlVG9JbWFnZSA9IChwb2ludGVyWCAtIGN1cnJlbnRJbWFnZVJlYWxPZmZzZXRYKSAvIGN1cnJlbnRab29tTXVsdGlwbGllcjtcbiAgICAgIHZhciBjdXJyZW50UG9pbnRlcllSZWxhdGl2ZVRvSW1hZ2UgPSAocG9pbnRlclkgLSBjdXJyZW50SW1hZ2VSZWFsT2Zmc2V0WSkgLyBjdXJyZW50Wm9vbU11bHRpcGxpZXI7XG4gICAgICB2YXIgbmV4dEltYWdlUmVhbE9mZnNldFggPSBwb2ludGVyWCAtIGN1cnJlbnRQb2ludGVyWFJlbGF0aXZlVG9JbWFnZSAqIG5leHRab29tTXVsdGlwbGllcjtcbiAgICAgIHZhciBuZXh0SW1hZ2VSZWFsT2Zmc2V0WSA9IHBvaW50ZXJZIC0gY3VycmVudFBvaW50ZXJZUmVsYXRpdmVUb0ltYWdlICogbmV4dFpvb21NdWx0aXBsaWVyO1xuICAgICAgdmFyIG5leHRJbWFnZU9mZnNldFggPSAoYm94UmVjdC53aWR0aCAtIGltYWdlQmFzZVNpemUud2lkdGggKiBuZXh0Wm9vbU11bHRpcGxpZXIpIC8gMjtcbiAgICAgIHZhciBuZXh0SW1hZ2VPZmZzZXRZID0gKGJveFJlY3QuaGVpZ2h0IC0gaW1hZ2VCYXNlU2l6ZS5oZWlnaHQgKiBuZXh0Wm9vbU11bHRpcGxpZXIpIC8gMjtcbiAgICAgIHZhciBuZXh0T2Zmc2V0WCA9IG5leHRJbWFnZU9mZnNldFggLSBuZXh0SW1hZ2VSZWFsT2Zmc2V0WDtcbiAgICAgIHZhciBuZXh0T2Zmc2V0WSA9IG5leHRJbWFnZU9mZnNldFkgLSBuZXh0SW1hZ2VSZWFsT2Zmc2V0WTsgLy8gV2hlbiB6b29taW5nIG91dCwgbGltaXQgdGhlIG9mZnNldCBzbyB0aGluZ3MgZG9uJ3QgZ2V0IGxlZnQgYXNrZXdcblxuICAgICAgaWYgKHRoaXMuY3VycmVudEFjdGlvbiAhPT0gQUNUSU9OX1BJTkNIKSB7XG4gICAgICAgIHZhciBtYXhPZmZzZXRzID0gdGhpcy5nZXRNYXhPZmZzZXRzKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuem9vbUxldmVsID4gbmV4dFpvb21MZXZlbCkge1xuICAgICAgICAgIG5leHRPZmZzZXRYID0gTWF0aC5tYXgobWF4T2Zmc2V0cy5taW5YLCBNYXRoLm1pbihtYXhPZmZzZXRzLm1heFgsIG5leHRPZmZzZXRYKSk7XG4gICAgICAgICAgbmV4dE9mZnNldFkgPSBNYXRoLm1heChtYXhPZmZzZXRzLm1pblksIE1hdGgubWluKG1heE9mZnNldHMubWF4WSwgbmV4dE9mZnNldFkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgem9vbUxldmVsOiBuZXh0Wm9vbUxldmVsLFxuICAgICAgICBvZmZzZXRYOiBuZXh0T2Zmc2V0WCxcbiAgICAgICAgb2Zmc2V0WTogbmV4dE9mZnNldFlcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZUlmQ2xpY2tJbm5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZUlmQ2xpY2tJbm5lcihldmVudCkge1xuICAgICAgaWYgKCF0aGlzLnByZXZlbnRJbm5lckNsb3NlICYmIGV2ZW50LnRhcmdldC5jbGFzc05hbWUuc2VhcmNoKC9cXGJyaWwtaW5uZXJcXGIvKSA+IC0xKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdENsb3NlKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHVzZXIga2V5Ym9hcmQgYWN0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlS2V5SW5wdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlS2V5SW5wdXQoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyAvLyBJZ25vcmUga2V5IGlucHV0IGR1cmluZyBhbmltYXRpb25zXG5cbiAgICAgIGlmICh0aGlzLmlzQW5pbWF0aW5nKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBBbGxvdyBzbGlnaHRseSBmYXN0ZXIgbmF2aWdhdGlvbiB0aHJvdWdoIHRoZSBpbWFnZXMgd2hlbiB1c2VyIHByZXNzZXMga2V5cyByZXBlYXRlZGx5XG5cblxuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgICAgdGhpcy5sYXN0S2V5RG93blRpbWUgLT0gdGhpcy5wcm9wcy5rZXlSZXBlYXRLZXl1cEJvbnVzO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBrZXlDb2RlID0gZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZTsgLy8gSWdub3JlIGtleSBwcmVzc2VzIHRoYXQgaGFwcGVuIHRvbyBjbG9zZSB0byBlYWNoIG90aGVyICh3aGVuIHJhcGlkIGZpcmUga2V5IHByZXNzaW5nIG9yIGhvbGRpbmcgZG93biB0aGUga2V5KVxuICAgICAgLy8gQnV0IGFsbG93IGl0IGlmIGl0J3MgYSBsaWdodGJveCBjbG9zaW5nIGFjdGlvblxuXG4gICAgICB2YXIgY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICBpZiAoY3VycmVudFRpbWUuZ2V0VGltZSgpIC0gdGhpcy5sYXN0S2V5RG93blRpbWUgPCB0aGlzLnByb3BzLmtleVJlcGVhdExpbWl0ICYmIGtleUNvZGUgIT09IEtFWVMuRVNDKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sYXN0S2V5RG93blRpbWUgPSBjdXJyZW50VGltZS5nZXRUaW1lKCk7XG5cbiAgICAgIHN3aXRjaCAoa2V5Q29kZSkge1xuICAgICAgICAvLyBFU0Mga2V5IGNsb3NlcyB0aGUgbGlnaHRib3hcbiAgICAgICAgY2FzZSBLRVlTLkVTQzpcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMucmVxdWVzdENsb3NlKGV2ZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gTGVmdCBhcnJvdyBrZXkgbW92ZXMgdG8gcHJldmlvdXMgaW1hZ2VcblxuICAgICAgICBjYXNlIEtFWVMuTEVGVF9BUlJPVzpcbiAgICAgICAgICBpZiAoIXRoaXMucHJvcHMucHJldlNyYykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5rZXlQcmVzc2VkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnJlcXVlc3RNb3ZlUHJldihldmVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFJpZ2h0IGFycm93IGtleSBtb3ZlcyB0byBuZXh0IGltYWdlXG5cbiAgICAgICAgY2FzZSBLRVlTLlJJR0hUX0FSUk9XOlxuICAgICAgICAgIGlmICghdGhpcy5wcm9wcy5uZXh0U3JjKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLmtleVByZXNzZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMucmVxdWVzdE1vdmVOZXh0KGV2ZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGEgbW91c2Ugd2hlZWwgZXZlbnQgb3ZlciB0aGUgbGlnaHRib3ggY29udGFpbmVyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVPdXRlck1vdXNld2hlZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlT3V0ZXJNb3VzZXdoZWVsKGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXM4ID0gdGhpcztcblxuICAgICAgLy8gUHJldmVudCBzY3JvbGxpbmcgb2YgdGhlIGJhY2tncm91bmRcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgdmFyIHhUaHJlc2hvbGQgPSBXSEVFTF9NT1ZFX1hfVEhSRVNIT0xEO1xuICAgICAgdmFyIGFjdGlvbkRlbGF5ID0gMDtcbiAgICAgIHZhciBpbWFnZU1vdmVEZWxheSA9IDUwMDtcbiAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KHRoaXMucmVzZXRTY3JvbGxUaW1lb3V0KTtcbiAgICAgIHRoaXMucmVzZXRTY3JvbGxUaW1lb3V0ID0gdGhpcy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXM4LnNjcm9sbFggPSAwO1xuICAgICAgICBfdGhpczguc2Nyb2xsWSA9IDA7XG4gICAgICB9LCAzMDApOyAvLyBQcmV2ZW50IHJhcGlkLWZpcmUgem9vbSBiZWhhdmlvclxuXG4gICAgICBpZiAodGhpcy53aGVlbEFjdGlvblRpbWVvdXQgIT09IG51bGwgfHwgdGhpcy5pc0FuaW1hdGluZygpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKE1hdGguYWJzKGV2ZW50LmRlbHRhWSkgPCBNYXRoLmFicyhldmVudC5kZWx0YVgpKSB7XG4gICAgICAgIC8vIGhhbmRsZSBob3Jpem9udGFsIHNjcm9sbHMgd2l0aCBpbWFnZSBtb3Zlc1xuICAgICAgICB0aGlzLnNjcm9sbFkgPSAwO1xuICAgICAgICB0aGlzLnNjcm9sbFggKz0gZXZlbnQuZGVsdGFYO1xuICAgICAgICB2YXIgYmlnTGVhcFggPSB4VGhyZXNob2xkIC8gMjsgLy8gSWYgdGhlIHNjcm9sbCBhbW91bnQgaGFzIGFjY3VtdWxhdGVkIHN1ZmZpY2llbnRseSwgb3IgYSBsYXJnZSBsZWFwIHdhcyB0YWtlblxuXG4gICAgICAgIGlmICh0aGlzLnNjcm9sbFggPj0geFRocmVzaG9sZCB8fCBldmVudC5kZWx0YVggPj0gYmlnTGVhcFgpIHtcbiAgICAgICAgICAvLyBTY3JvbGwgcmlnaHQgbW92ZXMgdG8gbmV4dFxuICAgICAgICAgIHRoaXMucmVxdWVzdE1vdmVOZXh0KGV2ZW50KTtcbiAgICAgICAgICBhY3Rpb25EZWxheSA9IGltYWdlTW92ZURlbGF5O1xuICAgICAgICAgIHRoaXMuc2Nyb2xsWCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zY3JvbGxYIDw9IC0xICogeFRocmVzaG9sZCB8fCBldmVudC5kZWx0YVggPD0gLTEgKiBiaWdMZWFwWCkge1xuICAgICAgICAgIC8vIFNjcm9sbCBsZWZ0IG1vdmVzIHRvIHByZXZpb3VzXG4gICAgICAgICAgdGhpcy5yZXF1ZXN0TW92ZVByZXYoZXZlbnQpO1xuICAgICAgICAgIGFjdGlvbkRlbGF5ID0gaW1hZ2VNb3ZlRGVsYXk7XG4gICAgICAgICAgdGhpcy5zY3JvbGxYID0gMDtcbiAgICAgICAgfVxuICAgICAgfSAvLyBBbGxvdyBzdWNjZXNzaXZlIGFjdGlvbnMgYWZ0ZXIgdGhlIHNldCBkZWxheVxuXG5cbiAgICAgIGlmIChhY3Rpb25EZWxheSAhPT0gMCkge1xuICAgICAgICB0aGlzLndoZWVsQWN0aW9uVGltZW91dCA9IHRoaXMuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXM4LndoZWVsQWN0aW9uVGltZW91dCA9IG51bGw7XG4gICAgICAgIH0sIGFjdGlvbkRlbGF5KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlSW1hZ2VNb3VzZVdoZWVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUltYWdlTW91c2VXaGVlbChldmVudCkge1xuICAgICAgdmFyIHlUaHJlc2hvbGQgPSBXSEVFTF9NT1ZFX1lfVEhSRVNIT0xEO1xuXG4gICAgICBpZiAoTWF0aC5hYnMoZXZlbnQuZGVsdGFZKSA+PSBNYXRoLmFicyhldmVudC5kZWx0YVgpKSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyAvLyBJZiB0aGUgdmVydGljYWwgc2Nyb2xsIGFtb3VudCB3YXMgbGFyZ2UgZW5vdWdoLCBwZXJmb3JtIGEgem9vbVxuXG4gICAgICAgIGlmIChNYXRoLmFicyhldmVudC5kZWx0YVkpIDwgeVRocmVzaG9sZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2Nyb2xsWCA9IDA7XG4gICAgICAgIHRoaXMuc2Nyb2xsWSArPSBldmVudC5kZWx0YVk7XG4gICAgICAgIHRoaXMuY2hhbmdlWm9vbSh0aGlzLnN0YXRlLnpvb21MZXZlbCAtIGV2ZW50LmRlbHRhWSwgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhIGRvdWJsZSBjbGljayBvbiB0aGUgY3VycmVudCBpbWFnZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlSW1hZ2VEb3VibGVDbGlja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVJbWFnZURvdWJsZUNsaWNrKGV2ZW50KSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS56b29tTGV2ZWwgPiBNSU5fWk9PTV9MRVZFTCkge1xuICAgICAgICAvLyBBIGRvdWJsZSBjbGljayB3aGVuIHpvb21lZCBpbiB6b29tcyBhbGwgdGhlIHdheSBvdXRcbiAgICAgICAgdGhpcy5jaGFuZ2Vab29tKE1JTl9aT09NX0xFVkVMLCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEEgZG91YmxlIGNsaWNrIHdoZW4gem9vbWVkIGFsbCB0aGUgd2F5IG91dCB6b29tcyBpblxuICAgICAgICB0aGlzLmNoYW5nZVpvb20odGhpcy5zdGF0ZS56b29tTGV2ZWwgKyBaT09NX0JVVFRPTl9JTkNSRU1FTlRfU0laRSwgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNob3VsZEhhbmRsZUV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3VsZEhhbmRsZUV2ZW50KHNvdXJjZSkge1xuICAgICAgaWYgKHRoaXMuZXZlbnRzU291cmNlID09PSBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmV2ZW50c1NvdXJjZSA9PT0gU09VUkNFX0FOWSkge1xuICAgICAgICB0aGlzLmV2ZW50c1NvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoc291cmNlKSB7XG4gICAgICAgIGNhc2UgU09VUkNFX01PVVNFOlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICBjYXNlIFNPVVJDRV9UT1VDSDpcbiAgICAgICAgICB0aGlzLmV2ZW50c1NvdXJjZSA9IFNPVVJDRV9UT1VDSDtcbiAgICAgICAgICB0aGlzLmZpbHRlclBvaW50ZXJzQnlTb3VyY2UoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBjYXNlIFNPVVJDRV9QT0lOVEVSOlxuICAgICAgICAgIGlmICh0aGlzLmV2ZW50c1NvdXJjZSA9PT0gU09VUkNFX01PVVNFKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50c1NvdXJjZSA9IFNPVVJDRV9QT0lOVEVSO1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJQb2ludGVyc0J5U291cmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFBvaW50ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUG9pbnRlcihwb2ludGVyKSB7XG4gICAgICB0aGlzLnBvaW50ZXJMaXN0LnB1c2gocG9pbnRlcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVBvaW50ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlUG9pbnRlcihwb2ludGVyKSB7XG4gICAgICB0aGlzLnBvaW50ZXJMaXN0ID0gdGhpcy5wb2ludGVyTGlzdC5maWx0ZXIoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIGlkID0gX3JlZi5pZDtcbiAgICAgICAgcmV0dXJuIGlkICE9PSBwb2ludGVyLmlkO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbHRlclBvaW50ZXJzQnlTb3VyY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlsdGVyUG9pbnRlcnNCeVNvdXJjZSgpIHtcbiAgICAgIHZhciBfdGhpczkgPSB0aGlzO1xuXG4gICAgICB0aGlzLnBvaW50ZXJMaXN0ID0gdGhpcy5wb2ludGVyTGlzdC5maWx0ZXIoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBfcmVmMi5zb3VyY2U7XG4gICAgICAgIHJldHVybiBzb3VyY2UgPT09IF90aGlzOS5ldmVudHNTb3VyY2U7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlTW91c2VEb3duXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bihldmVudCkge1xuICAgICAgaWYgKHRoaXMuc2hvdWxkSGFuZGxlRXZlbnQoU09VUkNFX01PVVNFKSAmJiBSZWFjdEltYWdlTGlnaHRib3guaXNUYXJnZXRNYXRjaEltYWdlKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgdGhpcy5hZGRQb2ludGVyKFJlYWN0SW1hZ2VMaWdodGJveC5wYXJzZU1vdXNlRXZlbnQoZXZlbnQpKTtcbiAgICAgICAgdGhpcy5tdWx0aVBvaW50ZXJTdGFydChldmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZU1vdXNlTW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgIGlmICh0aGlzLnNob3VsZEhhbmRsZUV2ZW50KFNPVVJDRV9NT1VTRSkpIHtcbiAgICAgICAgdGhpcy5tdWx0aVBvaW50ZXJNb3ZlKGV2ZW50LCBbUmVhY3RJbWFnZUxpZ2h0Ym94LnBhcnNlTW91c2VFdmVudChldmVudCldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlTW91c2VVcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVNb3VzZVVwKGV2ZW50KSB7XG4gICAgICBpZiAodGhpcy5zaG91bGRIYW5kbGVFdmVudChTT1VSQ0VfTU9VU0UpKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlUG9pbnRlcihSZWFjdEltYWdlTGlnaHRib3gucGFyc2VNb3VzZUV2ZW50KGV2ZW50KSk7XG4gICAgICAgIHRoaXMubXVsdGlQb2ludGVyRW5kKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlUG9pbnRlckV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJFdmVudChldmVudCkge1xuICAgICAgaWYgKHRoaXMuc2hvdWxkSGFuZGxlRXZlbnQoU09VUkNFX1BPSU5URVIpKSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ3BvaW50ZXJkb3duJzpcbiAgICAgICAgICAgIGlmIChSZWFjdEltYWdlTGlnaHRib3guaXNUYXJnZXRNYXRjaEltYWdlKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5hZGRQb2ludGVyKFJlYWN0SW1hZ2VMaWdodGJveC5wYXJzZVBvaW50ZXJFdmVudChldmVudCkpO1xuICAgICAgICAgICAgICB0aGlzLm11bHRpUG9pbnRlclN0YXJ0KGV2ZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdwb2ludGVybW92ZSc6XG4gICAgICAgICAgICB0aGlzLm11bHRpUG9pbnRlck1vdmUoZXZlbnQsIFtSZWFjdEltYWdlTGlnaHRib3gucGFyc2VQb2ludGVyRXZlbnQoZXZlbnQpXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3BvaW50ZXJ1cCc6XG4gICAgICAgICAgY2FzZSAncG9pbnRlcmNhbmNlbCc6XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVBvaW50ZXIoUmVhY3RJbWFnZUxpZ2h0Ym94LnBhcnNlUG9pbnRlckV2ZW50KGV2ZW50KSk7XG4gICAgICAgICAgICB0aGlzLm11bHRpUG9pbnRlckVuZChldmVudCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVUb3VjaFN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVRvdWNoU3RhcnQoZXZlbnQpIHtcbiAgICAgIHZhciBfdGhpczEwID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuc2hvdWxkSGFuZGxlRXZlbnQoU09VUkNFX1RPVUNIKSAmJiBSZWFjdEltYWdlTGlnaHRib3guaXNUYXJnZXRNYXRjaEltYWdlKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgW10uZm9yRWFjaC5jYWxsKGV2ZW50LmNoYW5nZWRUb3VjaGVzLCBmdW5jdGlvbiAoZXZlbnRUb3VjaCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczEwLmFkZFBvaW50ZXIoUmVhY3RJbWFnZUxpZ2h0Ym94LnBhcnNlVG91Y2hQb2ludGVyKGV2ZW50VG91Y2gpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubXVsdGlQb2ludGVyU3RhcnQoZXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVUb3VjaE1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlVG91Y2hNb3ZlKGV2ZW50KSB7XG4gICAgICBpZiAodGhpcy5zaG91bGRIYW5kbGVFdmVudChTT1VSQ0VfVE9VQ0gpKSB7XG4gICAgICAgIHRoaXMubXVsdGlQb2ludGVyTW92ZShldmVudCwgW10ubWFwLmNhbGwoZXZlbnQuY2hhbmdlZFRvdWNoZXMsIGZ1bmN0aW9uIChldmVudFRvdWNoKSB7XG4gICAgICAgICAgcmV0dXJuIFJlYWN0SW1hZ2VMaWdodGJveC5wYXJzZVRvdWNoUG9pbnRlcihldmVudFRvdWNoKTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVUb3VjaEVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVUb3VjaEVuZChldmVudCkge1xuICAgICAgdmFyIF90aGlzMTEgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5zaG91bGRIYW5kbGVFdmVudChTT1VSQ0VfVE9VQ0gpKSB7XG4gICAgICAgIFtdLm1hcC5jYWxsKGV2ZW50LmNoYW5nZWRUb3VjaGVzLCBmdW5jdGlvbiAodG91Y2gpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMxMS5yZW1vdmVQb2ludGVyKFJlYWN0SW1hZ2VMaWdodGJveC5wYXJzZVRvdWNoUG9pbnRlcih0b3VjaCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tdWx0aVBvaW50ZXJFbmQoZXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWNpZGVNb3ZlT3JTd2lwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNpZGVNb3ZlT3JTd2lwZShwb2ludGVyKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS56b29tTGV2ZWwgPD0gTUlOX1pPT01fTEVWRUwpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVTd2lwZVN0YXJ0KHBvaW50ZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVNb3ZlU3RhcnQocG9pbnRlcik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm11bHRpUG9pbnRlclN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG11bHRpUG9pbnRlclN0YXJ0KGV2ZW50KSB7XG4gICAgICB0aGlzLmhhbmRsZUVuZChudWxsKTtcblxuICAgICAgc3dpdGNoICh0aGlzLnBvaW50ZXJMaXN0Lmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuZGVjaWRlTW92ZU9yU3dpcGUodGhpcy5wb2ludGVyTGlzdFswXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVBpbmNoU3RhcnQodGhpcy5wb2ludGVyTGlzdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm11bHRpUG9pbnRlck1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbXVsdGlQb2ludGVyTW92ZShldmVudCwgcG9pbnRlckxpc3QpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5jdXJyZW50QWN0aW9uKSB7XG4gICAgICAgIGNhc2UgQUNUSU9OX01PVkU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW92ZShwb2ludGVyTGlzdFswXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBBQ1RJT05fU1dJUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU3dpcGUocG9pbnRlckxpc3RbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgQUNUSU9OX1BJTkNIOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVBpbmNoKHBvaW50ZXJMaXN0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibXVsdGlQb2ludGVyRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG11bHRpUG9pbnRlckVuZChldmVudCkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudEFjdGlvbiAhPT0gQUNUSU9OX05PTkUpIHtcbiAgICAgICAgdGhpcy5zZXRQcmV2ZW50SW5uZXJDbG9zZSgpO1xuICAgICAgICB0aGlzLmhhbmRsZUVuZChldmVudCk7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAodGhpcy5wb2ludGVyTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzU291cmNlID0gU09VUkNFX0FOWTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuZGVjaWRlTW92ZU9yU3dpcGUodGhpcy5wb2ludGVyTGlzdFswXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVBpbmNoU3RhcnQodGhpcy5wb2ludGVyTGlzdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVFbmQoZXZlbnQpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5jdXJyZW50QWN0aW9uKSB7XG4gICAgICAgIGNhc2UgQUNUSU9OX01PVkU6XG4gICAgICAgICAgdGhpcy5oYW5kbGVNb3ZlRW5kKGV2ZW50KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEFDVElPTl9TV0lQRTpcbiAgICAgICAgICB0aGlzLmhhbmRsZVN3aXBlRW5kKGV2ZW50KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEFDVElPTl9QSU5DSDpcbiAgICAgICAgICB0aGlzLmhhbmRsZVBpbmNoRW5kKGV2ZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IC8vIEhhbmRsZSBtb3ZlIHN0YXJ0IG92ZXIgdGhlIGxpZ2h0Ym94IGNvbnRhaW5lclxuICAgIC8vIFRoaXMgaGFwcGVuczpcbiAgICAvLyAtIE9uIGEgbW91c2VEb3duIGV2ZW50XG4gICAgLy8gLSBPbiBhIHRvdWNoc3RhcnQgZXZlbnRcblxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZU1vdmVTdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVNb3ZlU3RhcnQoX3JlZjMpIHtcbiAgICAgIHZhciBjbGllbnRYID0gX3JlZjMueCxcbiAgICAgICAgICBjbGllbnRZID0gX3JlZjMueTtcblxuICAgICAgaWYgKCF0aGlzLnByb3BzLmVuYWJsZVpvb20pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmN1cnJlbnRBY3Rpb24gPSBBQ1RJT05fTU9WRTtcbiAgICAgIHRoaXMubW92ZVN0YXJ0WCA9IGNsaWVudFg7XG4gICAgICB0aGlzLm1vdmVTdGFydFkgPSBjbGllbnRZO1xuICAgICAgdGhpcy5tb3ZlU3RhcnRPZmZzZXRYID0gdGhpcy5zdGF0ZS5vZmZzZXRYO1xuICAgICAgdGhpcy5tb3ZlU3RhcnRPZmZzZXRZID0gdGhpcy5zdGF0ZS5vZmZzZXRZO1xuICAgIH0gLy8gSGFuZGxlIGRyYWdnaW5nIG92ZXIgdGhlIGxpZ2h0Ym94IGNvbnRhaW5lclxuICAgIC8vIFRoaXMgaGFwcGVuczpcbiAgICAvLyAtIEFmdGVyIGEgbW91c2VEb3duIGFuZCBiZWZvcmUgYSBtb3VzZVVwIGV2ZW50XG4gICAgLy8gLSBBZnRlciBhIHRvdWNoc3RhcnQgYW5kIGJlZm9yZSBhIHRvdWNoZW5kIGV2ZW50XG5cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVNb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU1vdmUoX3JlZjQpIHtcbiAgICAgIHZhciBjbGllbnRYID0gX3JlZjQueCxcbiAgICAgICAgICBjbGllbnRZID0gX3JlZjQueTtcbiAgICAgIHZhciBuZXdPZmZzZXRYID0gdGhpcy5tb3ZlU3RhcnRYIC0gY2xpZW50WCArIHRoaXMubW92ZVN0YXJ0T2Zmc2V0WDtcbiAgICAgIHZhciBuZXdPZmZzZXRZID0gdGhpcy5tb3ZlU3RhcnRZIC0gY2xpZW50WSArIHRoaXMubW92ZVN0YXJ0T2Zmc2V0WTtcblxuICAgICAgaWYgKHRoaXMuc3RhdGUub2Zmc2V0WCAhPT0gbmV3T2Zmc2V0WCB8fCB0aGlzLnN0YXRlLm9mZnNldFkgIT09IG5ld09mZnNldFkpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgb2Zmc2V0WDogbmV3T2Zmc2V0WCxcbiAgICAgICAgICBvZmZzZXRZOiBuZXdPZmZzZXRZXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVNb3ZlRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU1vdmVFbmQoKSB7XG4gICAgICB2YXIgX3RoaXMxMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuY3VycmVudEFjdGlvbiA9IEFDVElPTl9OT05FO1xuICAgICAgdGhpcy5tb3ZlU3RhcnRYID0gMDtcbiAgICAgIHRoaXMubW92ZVN0YXJ0WSA9IDA7XG4gICAgICB0aGlzLm1vdmVTdGFydE9mZnNldFggPSAwO1xuICAgICAgdGhpcy5tb3ZlU3RhcnRPZmZzZXRZID0gMDsgLy8gU25hcCBpbWFnZSBiYWNrIGludG8gZnJhbWUgaWYgb3V0c2lkZSBtYXggb2Zmc2V0IHJhbmdlXG5cbiAgICAgIHZhciBtYXhPZmZzZXRzID0gdGhpcy5nZXRNYXhPZmZzZXRzKCk7XG4gICAgICB2YXIgbmV4dE9mZnNldFggPSBNYXRoLm1heChtYXhPZmZzZXRzLm1pblgsIE1hdGgubWluKG1heE9mZnNldHMubWF4WCwgdGhpcy5zdGF0ZS5vZmZzZXRYKSk7XG4gICAgICB2YXIgbmV4dE9mZnNldFkgPSBNYXRoLm1heChtYXhPZmZzZXRzLm1pblksIE1hdGgubWluKG1heE9mZnNldHMubWF4WSwgdGhpcy5zdGF0ZS5vZmZzZXRZKSk7XG5cbiAgICAgIGlmIChuZXh0T2Zmc2V0WCAhPT0gdGhpcy5zdGF0ZS5vZmZzZXRYIHx8IG5leHRPZmZzZXRZICE9PSB0aGlzLnN0YXRlLm9mZnNldFkpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgb2Zmc2V0WDogbmV4dE9mZnNldFgsXG4gICAgICAgICAgb2Zmc2V0WTogbmV4dE9mZnNldFksXG4gICAgICAgICAgc2hvdWxkQW5pbWF0ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczEyLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHNob3VsZEFuaW1hdGU6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIHRoaXMucHJvcHMuYW5pbWF0aW9uRHVyYXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVTd2lwZVN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVN3aXBlU3RhcnQoX3JlZjUpIHtcbiAgICAgIHZhciBjbGllbnRYID0gX3JlZjUueCxcbiAgICAgICAgICBjbGllbnRZID0gX3JlZjUueTtcbiAgICAgIHRoaXMuY3VycmVudEFjdGlvbiA9IEFDVElPTl9TV0lQRTtcbiAgICAgIHRoaXMuc3dpcGVTdGFydFggPSBjbGllbnRYO1xuICAgICAgdGhpcy5zd2lwZVN0YXJ0WSA9IGNsaWVudFk7XG4gICAgICB0aGlzLnN3aXBlRW5kWCA9IGNsaWVudFg7XG4gICAgICB0aGlzLnN3aXBlRW5kWSA9IGNsaWVudFk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZVN3aXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVN3aXBlKF9yZWY2KSB7XG4gICAgICB2YXIgY2xpZW50WCA9IF9yZWY2LngsXG4gICAgICAgICAgY2xpZW50WSA9IF9yZWY2Lnk7XG4gICAgICB0aGlzLnN3aXBlRW5kWCA9IGNsaWVudFg7XG4gICAgICB0aGlzLnN3aXBlRW5kWSA9IGNsaWVudFk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZVN3aXBlRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVN3aXBlRW5kKGV2ZW50KSB7XG4gICAgICB2YXIgeERpZmYgPSB0aGlzLnN3aXBlRW5kWCAtIHRoaXMuc3dpcGVTdGFydFg7XG4gICAgICB2YXIgeERpZmZBYnMgPSBNYXRoLmFicyh4RGlmZik7XG4gICAgICB2YXIgeURpZmZBYnMgPSBNYXRoLmFicyh0aGlzLnN3aXBlRW5kWSAtIHRoaXMuc3dpcGVTdGFydFkpO1xuICAgICAgdGhpcy5jdXJyZW50QWN0aW9uID0gQUNUSU9OX05PTkU7XG4gICAgICB0aGlzLnN3aXBlU3RhcnRYID0gMDtcbiAgICAgIHRoaXMuc3dpcGVTdGFydFkgPSAwO1xuICAgICAgdGhpcy5zd2lwZUVuZFggPSAwO1xuICAgICAgdGhpcy5zd2lwZUVuZFkgPSAwO1xuXG4gICAgICBpZiAoIWV2ZW50IHx8IHRoaXMuaXNBbmltYXRpbmcoKSB8fCB4RGlmZkFicyA8IHlEaWZmQWJzICogMS41KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHhEaWZmQWJzIDwgTUlOX1NXSVBFX0RJU1RBTkNFKSB7XG4gICAgICAgIHZhciBib3hSZWN0ID0gdGhpcy5nZXRMaWdodGJveFJlY3QoKTtcblxuICAgICAgICBpZiAoeERpZmZBYnMgPCBib3hSZWN0LndpZHRoIC8gNCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoeERpZmYgPiAwICYmIHRoaXMucHJvcHMucHJldlNyYykge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLnJlcXVlc3RNb3ZlUHJldigpO1xuICAgICAgfSBlbHNlIGlmICh4RGlmZiA8IDAgJiYgdGhpcy5wcm9wcy5uZXh0U3JjKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMucmVxdWVzdE1vdmVOZXh0KCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbGN1bGF0ZVBpbmNoRGlzdGFuY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlUGluY2hEaXN0YW5jZSgpIHtcbiAgICAgIHZhciBfcmVmNyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5waW5jaFRvdWNoTGlzdCxcbiAgICAgICAgICBfcmVmOCA9IF9zbGljZWRUb0FycmF5KF9yZWY3LCAyKSxcbiAgICAgICAgICBhID0gX3JlZjhbMF0sXG4gICAgICAgICAgYiA9IF9yZWY4WzFdO1xuXG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGEueCAtIGIueCwgMikgKyBNYXRoLnBvdyhhLnkgLSBiLnksIDIpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FsY3VsYXRlUGluY2hDZW50ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlUGluY2hDZW50ZXIoKSB7XG4gICAgICB2YXIgX3JlZjkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMucGluY2hUb3VjaExpc3QsXG4gICAgICAgICAgX3JlZjEwID0gX3NsaWNlZFRvQXJyYXkoX3JlZjksIDIpLFxuICAgICAgICAgIGEgPSBfcmVmMTBbMF0sXG4gICAgICAgICAgYiA9IF9yZWYxMFsxXTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogYS54IC0gKGEueCAtIGIueCkgLyAyLFxuICAgICAgICB5OiBhLnkgLSAoYS55IC0gYi55KSAvIDJcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZVBpbmNoU3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlUGluY2hTdGFydChwb2ludGVyTGlzdCkge1xuICAgICAgaWYgKCF0aGlzLnByb3BzLmVuYWJsZVpvb20pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmN1cnJlbnRBY3Rpb24gPSBBQ1RJT05fUElOQ0g7XG4gICAgICB0aGlzLnBpbmNoVG91Y2hMaXN0ID0gcG9pbnRlckxpc3QubWFwKGZ1bmN0aW9uIChfcmVmMTEpIHtcbiAgICAgICAgdmFyIGlkID0gX3JlZjExLmlkLFxuICAgICAgICAgICAgeCA9IF9yZWYxMS54LFxuICAgICAgICAgICAgeSA9IF9yZWYxMS55O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5waW5jaERpc3RhbmNlID0gdGhpcy5jYWxjdWxhdGVQaW5jaERpc3RhbmNlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZVBpbmNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVBpbmNoKHBvaW50ZXJMaXN0KSB7XG4gICAgICB0aGlzLnBpbmNoVG91Y2hMaXN0ID0gdGhpcy5waW5jaFRvdWNoTGlzdC5tYXAoZnVuY3Rpb24gKG9sZFBvaW50ZXIpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludGVyTGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGlmIChwb2ludGVyTGlzdFtpXS5pZCA9PT0gb2xkUG9pbnRlci5pZCkge1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50ZXJMaXN0W2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvbGRQb2ludGVyO1xuICAgICAgfSk7XG4gICAgICB2YXIgbmV3RGlzdGFuY2UgPSB0aGlzLmNhbGN1bGF0ZVBpbmNoRGlzdGFuY2UoKTtcbiAgICAgIHZhciB6b29tTGV2ZWwgPSB0aGlzLnN0YXRlLnpvb21MZXZlbCArIG5ld0Rpc3RhbmNlIC0gdGhpcy5waW5jaERpc3RhbmNlO1xuICAgICAgdGhpcy5waW5jaERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG5cbiAgICAgIHZhciBfdGhpcyRjYWxjdWxhdGVQaW5jaEMgPSB0aGlzLmNhbGN1bGF0ZVBpbmNoQ2VudGVyKHRoaXMucGluY2hUb3VjaExpc3QpLFxuICAgICAgICAgIGNsaWVudFggPSBfdGhpcyRjYWxjdWxhdGVQaW5jaEMueCxcbiAgICAgICAgICBjbGllbnRZID0gX3RoaXMkY2FsY3VsYXRlUGluY2hDLnk7XG5cbiAgICAgIHRoaXMuY2hhbmdlWm9vbSh6b29tTGV2ZWwsIGNsaWVudFgsIGNsaWVudFkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVQaW5jaEVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVQaW5jaEVuZCgpIHtcbiAgICAgIHRoaXMuY3VycmVudEFjdGlvbiA9IEFDVElPTl9OT05FO1xuICAgICAgdGhpcy5waW5jaFRvdWNoTGlzdCA9IG51bGw7XG4gICAgICB0aGlzLnBpbmNoRGlzdGFuY2UgPSAwO1xuICAgIH0gLy8gSGFuZGxlIHRoZSB3aW5kb3cgcmVzaXplIGV2ZW50XG5cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVXaW5kb3dSZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlV2luZG93UmVzaXplKCkge1xuICAgICAgdGhpcy5jbGVhclRpbWVvdXQodGhpcy5yZXNpemVUaW1lb3V0KTtcbiAgICAgIHRoaXMucmVzaXplVGltZW91dCA9IHRoaXMuc2V0VGltZW91dCh0aGlzLmZvcmNlVXBkYXRlLmJpbmQodGhpcyksIDEwMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZVpvb21JbkJ1dHRvbkNsaWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVpvb21JbkJ1dHRvbkNsaWNrKCkge1xuICAgICAgdmFyIG5leHRab29tTGV2ZWwgPSB0aGlzLnN0YXRlLnpvb21MZXZlbCArIFpPT01fQlVUVE9OX0lOQ1JFTUVOVF9TSVpFO1xuICAgICAgdGhpcy5jaGFuZ2Vab29tKG5leHRab29tTGV2ZWwpO1xuXG4gICAgICBpZiAobmV4dFpvb21MZXZlbCA9PT0gTUFYX1pPT01fTEVWRUwpIHtcbiAgICAgICAgdGhpcy56b29tT3V0QnRuLmN1cnJlbnQuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlWm9vbU91dEJ1dHRvbkNsaWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVpvb21PdXRCdXR0b25DbGljaygpIHtcbiAgICAgIHZhciBuZXh0Wm9vbUxldmVsID0gdGhpcy5zdGF0ZS56b29tTGV2ZWwgLSBaT09NX0JVVFRPTl9JTkNSRU1FTlRfU0laRTtcbiAgICAgIHRoaXMuY2hhbmdlWm9vbShuZXh0Wm9vbUxldmVsKTtcblxuICAgICAgaWYgKG5leHRab29tTGV2ZWwgPT09IE1JTl9aT09NX0xFVkVMKSB7XG4gICAgICAgIHRoaXMuem9vbUluQnRuLmN1cnJlbnQuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlQ2FwdGlvbk1vdXNld2hlZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ2FwdGlvbk1vdXNld2hlZWwoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICBpZiAoIXRoaXMuY2FwdGlvbi5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIF90aGlzJGNhcHRpb24kY3VycmVudCA9IHRoaXMuY2FwdGlvbi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgIGhlaWdodCA9IF90aGlzJGNhcHRpb24kY3VycmVudC5oZWlnaHQ7XG5cbiAgICAgIHZhciBfdGhpcyRjYXB0aW9uJGN1cnJlbnQyID0gdGhpcy5jYXB0aW9uLmN1cnJlbnQsXG4gICAgICAgICAgc2Nyb2xsSGVpZ2h0ID0gX3RoaXMkY2FwdGlvbiRjdXJyZW50Mi5zY3JvbGxIZWlnaHQsXG4gICAgICAgICAgc2Nyb2xsVG9wID0gX3RoaXMkY2FwdGlvbiRjdXJyZW50Mi5zY3JvbGxUb3A7XG5cbiAgICAgIGlmIChldmVudC5kZWx0YVkgPiAwICYmIGhlaWdodCArIHNjcm9sbFRvcCA+PSBzY3JvbGxIZWlnaHQgfHwgZXZlbnQuZGVsdGFZIDwgMCAmJiBzY3JvbGxUb3AgPD0gMCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH0gLy8gRGV0YWNoIGtleSBhbmQgbW91c2UgaW5wdXQgZXZlbnRzXG5cbiAgfSwge1xuICAgIGtleTogXCJpc0FuaW1hdGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0FuaW1hdGluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlLnNob3VsZEFuaW1hdGUgfHwgdGhpcy5zdGF0ZS5pc0Nsb3Npbmc7XG4gICAgfSAvLyBDaGVjayBpZiBpbWFnZSBpcyBsb2FkZWRcblxuICB9LCB7XG4gICAga2V5OiBcImlzSW1hZ2VMb2FkZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNJbWFnZUxvYWRlZChpbWFnZVNyYykge1xuICAgICAgcmV0dXJuIGltYWdlU3JjICYmIGltYWdlU3JjIGluIHRoaXMuaW1hZ2VDYWNoZSAmJiB0aGlzLmltYWdlQ2FjaGVbaW1hZ2VTcmNdLmxvYWRlZDtcbiAgICB9IC8vIExvYWQgaW1hZ2UgZnJvbSBzcmMgYW5kIGNhbGwgY2FsbGJhY2sgd2l0aCBpbWFnZSB3aWR0aCBhbmQgaGVpZ2h0IG9uIGxvYWRcblxuICB9LCB7XG4gICAga2V5OiBcImxvYWRJbWFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkSW1hZ2Uoc3JjVHlwZSwgaW1hZ2VTcmMsIGRvbmUpIHtcbiAgICAgIHZhciBfdGhpczEzID0gdGhpcztcblxuICAgICAgLy8gUmV0dXJuIHRoZSBpbWFnZSBpbmZvIGlmIGl0IGlzIGFscmVhZHkgY2FjaGVkXG4gICAgICBpZiAodGhpcy5pc0ltYWdlTG9hZGVkKGltYWdlU3JjKSkge1xuICAgICAgICB0aGlzLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGluTWVtb3J5SW1hZ2UgPSBuZXcgZ2xvYmFsLkltYWdlKCk7XG5cbiAgICAgIGlmICh0aGlzLnByb3BzLmltYWdlQ3Jvc3NPcmlnaW4pIHtcbiAgICAgICAgaW5NZW1vcnlJbWFnZS5jcm9zc09yaWdpbiA9IHRoaXMucHJvcHMuaW1hZ2VDcm9zc09yaWdpbjtcbiAgICAgIH1cblxuICAgICAgaW5NZW1vcnlJbWFnZS5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yRXZlbnQpIHtcbiAgICAgICAgX3RoaXMxMy5wcm9wcy5vbkltYWdlTG9hZEVycm9yKGltYWdlU3JjLCBzcmNUeXBlLCBlcnJvckV2ZW50KTsgLy8gZmFpbGVkIHRvIGxvYWQgc28gc2V0IHRoZSBzdGF0ZSBsb2FkRXJyb3JTdGF0dXNcblxuXG4gICAgICAgIF90aGlzMTMuc2V0U3RhdGUoZnVuY3Rpb24gKHByZXZTdGF0ZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2FkRXJyb3JTdGF0dXM6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBwcmV2U3RhdGUubG9hZEVycm9yU3RhdHVzKSwge30sIF9kZWZpbmVQcm9wZXJ0eSh7fSwgc3JjVHlwZSwgdHJ1ZSkpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZG9uZShlcnJvckV2ZW50KTtcbiAgICAgIH07XG5cbiAgICAgIGluTWVtb3J5SW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczEzLnByb3BzLm9uSW1hZ2VMb2FkKGltYWdlU3JjLCBzcmNUeXBlLCBpbk1lbW9yeUltYWdlKTtcblxuICAgICAgICBfdGhpczEzLmltYWdlQ2FjaGVbaW1hZ2VTcmNdID0ge1xuICAgICAgICAgIGxvYWRlZDogdHJ1ZSxcbiAgICAgICAgICB3aWR0aDogaW5NZW1vcnlJbWFnZS53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGluTWVtb3J5SW1hZ2UuaGVpZ2h0XG4gICAgICAgIH07XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH07XG5cbiAgICAgIGluTWVtb3J5SW1hZ2Uuc3JjID0gaW1hZ2VTcmM7XG4gICAgfSAvLyBMb2FkIGFsbCBpbWFnZXMgYW5kIHRoZWlyIHRodW1ibmFpbHNcblxuICB9LCB7XG4gICAga2V5OiBcImxvYWRBbGxJbWFnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZEFsbEltYWdlcygpIHtcbiAgICAgIHZhciBfdGhpczE0ID0gdGhpcztcblxuICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLnByb3BzO1xuXG4gICAgICB2YXIgZ2VuZXJhdGVMb2FkRG9uZUNhbGxiYWNrID0gZnVuY3Rpb24gZ2VuZXJhdGVMb2FkRG9uZUNhbGxiYWNrKHNyY1R5cGUsIGltYWdlU3JjKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgLy8gR2l2ZSB1cCBzaG93aW5nIGltYWdlIG9uIGVycm9yXG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gLy8gRG9uJ3QgcmVyZW5kZXIgaWYgdGhlIHNyYyBpcyBub3QgdGhlIHNhbWUgYXMgd2hlbiB0aGUgbG9hZCBzdGFydGVkXG4gICAgICAgICAgLy8gb3IgaWYgdGhlIGNvbXBvbmVudCBoYXMgdW5tb3VudGVkXG5cblxuICAgICAgICAgIGlmIChfdGhpczE0LnByb3BzW3NyY1R5cGVdICE9PSBpbWFnZVNyYyB8fCBfdGhpczE0LmRpZFVubW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IC8vIEZvcmNlIHJlcmVuZGVyIHdpdGggdGhlIG5ldyBpbWFnZVxuXG5cbiAgICAgICAgICBfdGhpczE0LmZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH07XG4gICAgICB9OyAvLyBMb2FkIHRoZSBpbWFnZXNcblxuXG4gICAgICB0aGlzLmdldFNyY1R5cGVzKCkuZm9yRWFjaChmdW5jdGlvbiAoc3JjVHlwZSkge1xuICAgICAgICB2YXIgdHlwZSA9IHNyY1R5cGUubmFtZTsgLy8gdGhlcmUgaXMgbm8gZXJyb3Igd2hlbiB3ZSB0cnkgdG8gbG9hZCBpdCBpbml0aWFsbHlcblxuICAgICAgICBpZiAocHJvcHNbdHlwZV0gJiYgX3RoaXMxNC5zdGF0ZS5sb2FkRXJyb3JTdGF0dXNbdHlwZV0pIHtcbiAgICAgICAgICBfdGhpczE0LnNldFN0YXRlKGZ1bmN0aW9uIChwcmV2U3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGxvYWRFcnJvclN0YXR1czogX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHByZXZTdGF0ZS5sb2FkRXJyb3JTdGF0dXMpLCB7fSwgX2RlZmluZVByb3BlcnR5KHt9LCB0eXBlLCBmYWxzZSkpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vIExvYWQgdW5sb2FkZWQgaW1hZ2VzXG5cblxuICAgICAgICBpZiAocHJvcHNbdHlwZV0gJiYgIV90aGlzMTQuaXNJbWFnZUxvYWRlZChwcm9wc1t0eXBlXSkpIHtcbiAgICAgICAgICBfdGhpczE0LmxvYWRJbWFnZSh0eXBlLCBwcm9wc1t0eXBlXSwgZ2VuZXJhdGVMb2FkRG9uZUNhbGxiYWNrKHR5cGUsIHByb3BzW3R5cGVdKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gLy8gUmVxdWVzdCB0aGF0IHRoZSBsaWdodGJveCBiZSBjbG9zZWRcblxuICB9LCB7XG4gICAga2V5OiBcInJlcXVlc3RDbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXF1ZXN0Q2xvc2UoZXZlbnQpIHtcbiAgICAgIHZhciBfdGhpczE1ID0gdGhpcztcblxuICAgICAgLy8gQ2FsbCB0aGUgcGFyZW50IGNsb3NlIHJlcXVlc3RcbiAgICAgIHZhciBjbG9zZUxpZ2h0Ym94ID0gZnVuY3Rpb24gY2xvc2VMaWdodGJveCgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMTUucHJvcHMub25DbG9zZVJlcXVlc3QoZXZlbnQpO1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMucHJvcHMuYW5pbWF0aW9uRGlzYWJsZWQgfHwgZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nICYmICF0aGlzLnByb3BzLmFuaW1hdGlvbk9uS2V5SW5wdXQpIHtcbiAgICAgICAgLy8gTm8gYW5pbWF0aW9uXG4gICAgICAgIGNsb3NlTGlnaHRib3goKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBXaXRoIGFuaW1hdGlvblxuICAgICAgLy8gU3RhcnQgY2xvc2luZyBhbmltYXRpb25cblxuXG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaXNDbG9zaW5nOiB0cnVlXG4gICAgICB9KTsgLy8gUGVyZm9ybSB0aGUgYWN0dWFsIGNsb3NpbmcgYXQgdGhlIGVuZCBvZiB0aGUgYW5pbWF0aW9uXG5cbiAgICAgIHRoaXMuc2V0VGltZW91dChjbG9zZUxpZ2h0Ym94LCB0aGlzLnByb3BzLmFuaW1hdGlvbkR1cmF0aW9uKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVxdWVzdE1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVxdWVzdE1vdmUoZGlyZWN0aW9uLCBldmVudCkge1xuICAgICAgdmFyIF90aGlzMTYgPSB0aGlzO1xuXG4gICAgICAvLyBSZXNldCB0aGUgem9vbSBsZXZlbCBvbiBpbWFnZSBtb3ZlXG4gICAgICB2YXIgbmV4dFN0YXRlID0ge1xuICAgICAgICB6b29tTGV2ZWw6IE1JTl9aT09NX0xFVkVMLFxuICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICBvZmZzZXRZOiAwXG4gICAgICB9OyAvLyBFbmFibGUgYW5pbWF0ZWQgc3RhdGVzXG5cbiAgICAgIGlmICghdGhpcy5wcm9wcy5hbmltYXRpb25EaXNhYmxlZCAmJiAoIXRoaXMua2V5UHJlc3NlZCB8fCB0aGlzLnByb3BzLmFuaW1hdGlvbk9uS2V5SW5wdXQpKSB7XG4gICAgICAgIG5leHRTdGF0ZS5zaG91bGRBbmltYXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMxNi5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBzaG91bGRBbmltYXRlOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCB0aGlzLnByb3BzLmFuaW1hdGlvbkR1cmF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5rZXlQcmVzc2VkID0gZmFsc2U7XG4gICAgICB0aGlzLm1vdmVSZXF1ZXN0ZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoZGlyZWN0aW9uID09PSAncHJldicpIHtcbiAgICAgICAgdGhpcy5rZXlDb3VudGVyIC09IDE7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUobmV4dFN0YXRlKTtcbiAgICAgICAgdGhpcy5wcm9wcy5vbk1vdmVQcmV2UmVxdWVzdChldmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmtleUNvdW50ZXIgKz0gMTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShuZXh0U3RhdGUpO1xuICAgICAgICB0aGlzLnByb3BzLm9uTW92ZU5leHRSZXF1ZXN0KGV2ZW50KTtcbiAgICAgIH1cbiAgICB9IC8vIFJlcXVlc3QgdG8gdHJhbnNpdGlvbiB0byB0aGUgbmV4dCBpbWFnZVxuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVxdWVzdE1vdmVOZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcXVlc3RNb3ZlTmV4dChldmVudCkge1xuICAgICAgdGhpcy5yZXF1ZXN0TW92ZSgnbmV4dCcsIGV2ZW50KTtcbiAgICB9IC8vIFJlcXVlc3QgdG8gdHJhbnNpdGlvbiB0byB0aGUgcHJldmlvdXMgaW1hZ2VcblxuICB9LCB7XG4gICAga2V5OiBcInJlcXVlc3RNb3ZlUHJldlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXF1ZXN0TW92ZVByZXYoZXZlbnQpIHtcbiAgICAgIHRoaXMucmVxdWVzdE1vdmUoJ3ByZXYnLCBldmVudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMxNyA9IHRoaXM7XG5cbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgYW5pbWF0aW9uRGlzYWJsZWQgPSBfdGhpcyRwcm9wcy5hbmltYXRpb25EaXNhYmxlZCxcbiAgICAgICAgICBhbmltYXRpb25EdXJhdGlvbiA9IF90aGlzJHByb3BzLmFuaW1hdGlvbkR1cmF0aW9uLFxuICAgICAgICAgIGNsaWNrT3V0c2lkZVRvQ2xvc2UgPSBfdGhpcyRwcm9wcy5jbGlja091dHNpZGVUb0Nsb3NlLFxuICAgICAgICAgIGRpc2NvdXJhZ2VEb3dubG9hZHMgPSBfdGhpcyRwcm9wcy5kaXNjb3VyYWdlRG93bmxvYWRzLFxuICAgICAgICAgIGVuYWJsZVpvb20gPSBfdGhpcyRwcm9wcy5lbmFibGVab29tLFxuICAgICAgICAgIGltYWdlVGl0bGUgPSBfdGhpcyRwcm9wcy5pbWFnZVRpdGxlLFxuICAgICAgICAgIG5leHRTcmMgPSBfdGhpcyRwcm9wcy5uZXh0U3JjLFxuICAgICAgICAgIHByZXZTcmMgPSBfdGhpcyRwcm9wcy5wcmV2U3JjLFxuICAgICAgICAgIHRvb2xiYXJCdXR0b25zID0gX3RoaXMkcHJvcHMudG9vbGJhckJ1dHRvbnMsXG4gICAgICAgICAgcmVhY3RNb2RhbFN0eWxlID0gX3RoaXMkcHJvcHMucmVhY3RNb2RhbFN0eWxlLFxuICAgICAgICAgIF9vbkFmdGVyT3BlbiA9IF90aGlzJHByb3BzLm9uQWZ0ZXJPcGVuLFxuICAgICAgICAgIGltYWdlQ3Jvc3NPcmlnaW4gPSBfdGhpcyRwcm9wcy5pbWFnZUNyb3NzT3JpZ2luLFxuICAgICAgICAgIHJlYWN0TW9kYWxQcm9wcyA9IF90aGlzJHByb3BzLnJlYWN0TW9kYWxQcm9wcyxcbiAgICAgICAgICBsb2FkZXIgPSBfdGhpcyRwcm9wcy5sb2FkZXI7XG4gICAgICB2YXIgX3RoaXMkc3RhdGUgPSB0aGlzLnN0YXRlLFxuICAgICAgICAgIHpvb21MZXZlbCA9IF90aGlzJHN0YXRlLnpvb21MZXZlbCxcbiAgICAgICAgICBvZmZzZXRYID0gX3RoaXMkc3RhdGUub2Zmc2V0WCxcbiAgICAgICAgICBvZmZzZXRZID0gX3RoaXMkc3RhdGUub2Zmc2V0WSxcbiAgICAgICAgICBpc0Nsb3NpbmcgPSBfdGhpcyRzdGF0ZS5pc0Nsb3NpbmcsXG4gICAgICAgICAgbG9hZEVycm9yU3RhdHVzID0gX3RoaXMkc3RhdGUubG9hZEVycm9yU3RhdHVzO1xuICAgICAgdmFyIGJveFNpemUgPSB0aGlzLmdldExpZ2h0Ym94UmVjdCgpO1xuICAgICAgdmFyIHRyYW5zaXRpb25TdHlsZSA9IHt9OyAvLyBUcmFuc2l0aW9uIHNldHRpbmdzIGZvciBzbGlkaW5nIGFuaW1hdGlvbnNcblxuICAgICAgaWYgKCFhbmltYXRpb25EaXNhYmxlZCAmJiB0aGlzLmlzQW5pbWF0aW5nKCkpIHtcbiAgICAgICAgdHJhbnNpdGlvblN0eWxlID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHRyYW5zaXRpb25TdHlsZSksIHt9LCB7XG4gICAgICAgICAgdHJhbnNpdGlvbjogXCJ0cmFuc2Zvcm0gXCIuY29uY2F0KGFuaW1hdGlvbkR1cmF0aW9uLCBcIm1zXCIpXG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBLZXkgZW5kaW5ncyB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gaW1hZ2VzIHdpdGggdGhlIHNhbWUgc3JjXG5cblxuICAgICAgdmFyIGtleUVuZGluZ3MgPSB7fTtcbiAgICAgIHRoaXMuZ2V0U3JjVHlwZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMTIpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBfcmVmMTIubmFtZSxcbiAgICAgICAgICAgIGtleUVuZGluZyA9IF9yZWYxMi5rZXlFbmRpbmc7XG4gICAgICAgIGtleUVuZGluZ3NbbmFtZV0gPSBrZXlFbmRpbmc7XG4gICAgICB9KTsgLy8gSW1hZ2VzIHRvIGJlIGRpc3BsYXllZFxuXG4gICAgICB2YXIgaW1hZ2VzID0gW107XG5cbiAgICAgIHZhciBhZGRJbWFnZSA9IGZ1bmN0aW9uIGFkZEltYWdlKHNyY1R5cGUsIGltYWdlQ2xhc3MsIHRyYW5zZm9ybXMpIHtcbiAgICAgICAgLy8gSWdub3JlIHR5cGVzIHRoYXQgaGF2ZSBubyBzb3VyY2UgZGVmaW5lZCBmb3IgdGhlaXIgZnVsbCBzaXplIGltYWdlXG4gICAgICAgIGlmICghX3RoaXMxNy5wcm9wc1tzcmNUeXBlXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBiZXN0SW1hZ2VJbmZvID0gX3RoaXMxNy5nZXRCZXN0SW1hZ2VGb3JUeXBlKHNyY1R5cGUpO1xuXG4gICAgICAgIHZhciBpbWFnZVN0eWxlID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHRyYW5zaXRpb25TdHlsZSksIFJlYWN0SW1hZ2VMaWdodGJveC5nZXRUcmFuc2Zvcm0oX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHRyYW5zZm9ybXMpLCBiZXN0SW1hZ2VJbmZvKSkpO1xuXG4gICAgICAgIGlmICh6b29tTGV2ZWwgPiBNSU5fWk9PTV9MRVZFTCkge1xuICAgICAgICAgIGltYWdlU3R5bGUuY3Vyc29yID0gJ21vdmUnO1xuICAgICAgICB9IC8vIHN1cHBvcnQgSUUgOSBhbmQgMTFcblxuXG4gICAgICAgIHZhciBoYXNUcnVlVmFsdWUgPSBmdW5jdGlvbiBoYXNUcnVlVmFsdWUob2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCkuc29tZShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07IC8vIHdoZW4gZXJyb3Igb24gb25lIG9mIHRoZSBsb2FkcyB0aGVuIHB1c2ggY3VzdG9tIGVycm9yIHN0dWZmXG5cblxuICAgICAgICBpZiAoYmVzdEltYWdlSW5mbyA9PT0gbnVsbCAmJiBoYXNUcnVlVmFsdWUobG9hZEVycm9yU3RhdHVzKSkge1xuICAgICAgICAgIGltYWdlcy5wdXNoKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwiXCIuY29uY2F0KGltYWdlQ2xhc3MsIFwiIHJpbF9faW1hZ2UgcmlsLWVycm9yZWRcIiksXG4gICAgICAgICAgICBzdHlsZTogaW1hZ2VTdHlsZSxcbiAgICAgICAgICAgIGtleTogX3RoaXMxNy5wcm9wc1tzcmNUeXBlXSArIGtleUVuZGluZ3Nbc3JjVHlwZV1cbiAgICAgICAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwicmlsX19lcnJvckNvbnRhaW5lclwiXG4gICAgICAgICAgfSwgX3RoaXMxNy5wcm9wcy5pbWFnZUxvYWRFcnJvck1lc3NhZ2UpKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJlc3RJbWFnZUluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgbG9hZGluZ0ljb24gPSBsb2FkZXIgIT09IHVuZGVmaW5lZCA/IGxvYWRlciA6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJyaWwtbG9hZGluZy1jaXJjbGUgcmlsX19sb2FkaW5nQ2lyY2xlIHJpbF9fbG9hZGluZ0NvbnRhaW5lcl9faWNvblwiXG4gICAgICAgICAgfSwgX3RvQ29uc3VtYWJsZUFycmF5KG5ldyBBcnJheSgxMikpLm1hcChmdW5jdGlvbiAoXywgaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9uby1hcnJheS1pbmRleC1rZXlcbiAgICAgICAgICAgICAga2V5OiBpbmRleCxcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcInJpbC1sb2FkaW5nLWNpcmNsZS1wb2ludCByaWxfX2xvYWRpbmdDaXJjbGVQb2ludFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KSk7IC8vIEZhbGwgYmFjayB0byBsb2FkaW5nIGljb24gaWYgdGhlIHRodW1ibmFpbCBoYXMgbm90IGJlZW4gbG9hZGVkXG5cbiAgICAgICAgICBpbWFnZXMucHVzaCggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcIlwiLmNvbmNhdChpbWFnZUNsYXNzLCBcIiByaWxfX2ltYWdlIHJpbC1ub3QtbG9hZGVkXCIpLFxuICAgICAgICAgICAgc3R5bGU6IGltYWdlU3R5bGUsXG4gICAgICAgICAgICBrZXk6IF90aGlzMTcucHJvcHNbc3JjVHlwZV0gKyBrZXlFbmRpbmdzW3NyY1R5cGVdXG4gICAgICAgICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInJpbF9fbG9hZGluZ0NvbnRhaW5lclwiXG4gICAgICAgICAgfSwgbG9hZGluZ0ljb24pKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGltYWdlU3JjID0gYmVzdEltYWdlSW5mby5zcmM7XG5cbiAgICAgICAgaWYgKGRpc2NvdXJhZ2VEb3dubG9hZHMpIHtcbiAgICAgICAgICBpbWFnZVN0eWxlLmJhY2tncm91bmRJbWFnZSA9IFwidXJsKCdcIi5jb25jYXQoaW1hZ2VTcmMsIFwiJylcIik7XG4gICAgICAgICAgaW1hZ2VzLnB1c2goIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJcIi5jb25jYXQoaW1hZ2VDbGFzcywgXCIgcmlsX19pbWFnZSByaWxfX2ltYWdlRGlzY291cmFnZXJcIiksXG4gICAgICAgICAgICBvbkRvdWJsZUNsaWNrOiBfdGhpczE3LmhhbmRsZUltYWdlRG91YmxlQ2xpY2ssXG4gICAgICAgICAgICBvbldoZWVsOiBfdGhpczE3LmhhbmRsZUltYWdlTW91c2VXaGVlbCxcbiAgICAgICAgICAgIHN0eWxlOiBpbWFnZVN0eWxlLFxuICAgICAgICAgICAga2V5OiBpbWFnZVNyYyArIGtleUVuZGluZ3Nbc3JjVHlwZV1cbiAgICAgICAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwicmlsLWRvd25sb2FkLWJsb2NrZXIgcmlsX19kb3dubG9hZEJsb2NrZXJcIlxuICAgICAgICAgIH0pKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW1hZ2VzLnB1c2goIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiaW1nXCIsIF9leHRlbmRzKHt9LCBpbWFnZUNyb3NzT3JpZ2luID8ge1xuICAgICAgICAgICAgY3Jvc3NPcmlnaW46IGltYWdlQ3Jvc3NPcmlnaW5cbiAgICAgICAgICB9IDoge30sIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJcIi5jb25jYXQoaW1hZ2VDbGFzcywgXCIgcmlsX19pbWFnZVwiKSxcbiAgICAgICAgICAgIG9uRG91YmxlQ2xpY2s6IF90aGlzMTcuaGFuZGxlSW1hZ2VEb3VibGVDbGljayxcbiAgICAgICAgICAgIG9uV2hlZWw6IF90aGlzMTcuaGFuZGxlSW1hZ2VNb3VzZVdoZWVsLFxuICAgICAgICAgICAgb25EcmFnU3RhcnQ6IGZ1bmN0aW9uIG9uRHJhZ1N0YXJ0KGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHlsZTogaW1hZ2VTdHlsZSxcbiAgICAgICAgICAgIHNyYzogaW1hZ2VTcmMsXG4gICAgICAgICAgICBrZXk6IGltYWdlU3JjICsga2V5RW5kaW5nc1tzcmNUeXBlXSxcbiAgICAgICAgICAgIGFsdDogdHlwZW9mIGltYWdlVGl0bGUgPT09ICdzdHJpbmcnID8gaW1hZ2VUaXRsZSA6IHRyYW5zbGF0ZSgnSW1hZ2UnKSxcbiAgICAgICAgICAgIGRyYWdnYWJsZTogZmFsc2VcbiAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgem9vbU11bHRpcGxpZXIgPSB0aGlzLmdldFpvb21NdWx0aXBsaWVyKCk7IC8vIE5leHQgSW1hZ2UgKGRpc3BsYXllZCBvbiB0aGUgcmlnaHQpXG5cbiAgICAgIGFkZEltYWdlKCduZXh0U3JjJywgJ3JpbC1pbWFnZS1uZXh0IHJpbF9faW1hZ2VOZXh0Jywge1xuICAgICAgICB4OiBib3hTaXplLndpZHRoXG4gICAgICB9KTsgLy8gTWFpbiBJbWFnZVxuXG4gICAgICBhZGRJbWFnZSgnbWFpblNyYycsICdyaWwtaW1hZ2UtY3VycmVudCcsIHtcbiAgICAgICAgeDogLTEgKiBvZmZzZXRYLFxuICAgICAgICB5OiAtMSAqIG9mZnNldFksXG4gICAgICAgIHpvb206IHpvb21NdWx0aXBsaWVyXG4gICAgICB9KTsgLy8gUHJldmlvdXMgSW1hZ2UgKGRpc3BsYXllZCBvbiB0aGUgbGVmdClcblxuICAgICAgYWRkSW1hZ2UoJ3ByZXZTcmMnLCAncmlsLWltYWdlLXByZXYgcmlsX19pbWFnZVByZXYnLCB7XG4gICAgICAgIHg6IC0xICogYm94U2l6ZS53aWR0aFxuICAgICAgfSk7XG4gICAgICB2YXIgbW9kYWxTdHlsZSA9IHtcbiAgICAgICAgb3ZlcmxheTogX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgIHpJbmRleDogMTAwMCxcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCdcbiAgICAgICAgfSwgcmVhY3RNb2RhbFN0eWxlLm92ZXJsYXkpLFxuICAgICAgICBjb250ZW50OiBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgICAvLyBOZWVkZWQsIG90aGVyd2lzZSBrZXlib2FyZCBzaG9ydGN1dHMgc2Nyb2xsIHRoZSBwYWdlXG4gICAgICAgICAgYm9yZGVyOiAnbm9uZScsXG4gICAgICAgICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgYm90dG9tOiAwXG4gICAgICAgIH0sIHJlYWN0TW9kYWxTdHlsZS5jb250ZW50KVxuICAgICAgfTtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChNb2RhbCwgX2V4dGVuZHMoe1xuICAgICAgICBpc09wZW46IHRydWUsXG4gICAgICAgIG9uUmVxdWVzdENsb3NlOiBjbGlja091dHNpZGVUb0Nsb3NlID8gdGhpcy5yZXF1ZXN0Q2xvc2UgOiB1bmRlZmluZWQsXG4gICAgICAgIG9uQWZ0ZXJPcGVuOiBmdW5jdGlvbiBvbkFmdGVyT3BlbigpIHtcbiAgICAgICAgICAvLyBGb2N1cyBvbiB0aGUgZGl2IHdpdGgga2V5IGhhbmRsZXJzXG4gICAgICAgICAgaWYgKF90aGlzMTcub3V0ZXJFbC5jdXJyZW50KSB7XG4gICAgICAgICAgICBfdGhpczE3Lm91dGVyRWwuY3VycmVudC5mb2N1cygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9vbkFmdGVyT3BlbigpO1xuICAgICAgICB9LFxuICAgICAgICBzdHlsZTogbW9kYWxTdHlsZSxcbiAgICAgICAgY29udGVudExhYmVsOiB0cmFuc2xhdGUoJ0xpZ2h0Ym94JyksXG4gICAgICAgIGFwcEVsZW1lbnQ6IHR5cGVvZiBnbG9iYWwud2luZG93ICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbC53aW5kb3cuZG9jdW1lbnQuYm9keSA6IHVuZGVmaW5lZFxuICAgICAgfSwgcmVhY3RNb2RhbFByb3BzKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGpzeC1hMTF5L25vLXN0YXRpYy1lbGVtZW50LWludGVyYWN0aW9uc1xuICAgICAgICAvLyBGbG9hdGluZyBtb2RhbCB3aXRoIGNsb3NpbmcgYW5pbWF0aW9uc1xuICAgICAgICBjbGFzc05hbWU6IFwicmlsLW91dGVyIHJpbF9fb3V0ZXIgcmlsX19vdXRlckFuaW1hdGluZyBcIi5jb25jYXQodGhpcy5wcm9wcy53cmFwcGVyQ2xhc3NOYW1lLCBcIiBcIikuY29uY2F0KGlzQ2xvc2luZyA/ICdyaWwtY2xvc2luZyByaWxfX291dGVyQ2xvc2luZycgOiAnJyksXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgdHJhbnNpdGlvbjogXCJvcGFjaXR5IFwiLmNvbmNhdChhbmltYXRpb25EdXJhdGlvbiwgXCJtc1wiKSxcbiAgICAgICAgICBhbmltYXRpb25EdXJhdGlvbjogXCJcIi5jb25jYXQoYW5pbWF0aW9uRHVyYXRpb24sIFwibXNcIiksXG4gICAgICAgICAgYW5pbWF0aW9uRGlyZWN0aW9uOiBpc0Nsb3NpbmcgPyAnbm9ybWFsJyA6ICdyZXZlcnNlJ1xuICAgICAgICB9LFxuICAgICAgICByZWY6IHRoaXMub3V0ZXJFbCxcbiAgICAgICAgb25XaGVlbDogdGhpcy5oYW5kbGVPdXRlck1vdXNld2hlZWwsXG4gICAgICAgIG9uTW91c2VNb3ZlOiB0aGlzLmhhbmRsZU1vdXNlTW92ZSxcbiAgICAgICAgb25Nb3VzZURvd246IHRoaXMuaGFuZGxlTW91c2VEb3duLFxuICAgICAgICBvblRvdWNoU3RhcnQ6IHRoaXMuaGFuZGxlVG91Y2hTdGFydCxcbiAgICAgICAgb25Ub3VjaE1vdmU6IHRoaXMuaGFuZGxlVG91Y2hNb3ZlLFxuICAgICAgICB0YWJJbmRleDogXCItMVwiIC8vIEVuYWJsZXMga2V5IGhhbmRsZXJzIG9uIGRpdlxuICAgICAgICAsXG4gICAgICAgIG9uS2V5RG93bjogdGhpcy5oYW5kbGVLZXlJbnB1dCxcbiAgICAgICAgb25LZXlVcDogdGhpcy5oYW5kbGVLZXlJbnB1dFxuICAgICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGpzeC1hMTF5L25vLXN0YXRpYy1lbGVtZW50LWludGVyYWN0aW9ucywganN4LWExMXkvY2xpY2stZXZlbnRzLWhhdmUta2V5LWV2ZW50c1xuICAgICAgICAvLyBJbWFnZSBob2xkZXJcbiAgICAgICAgY2xhc3NOYW1lOiBcInJpbC1pbm5lciByaWxfX2lubmVyXCIsXG4gICAgICAgIG9uQ2xpY2s6IGNsaWNrT3V0c2lkZVRvQ2xvc2UgPyB0aGlzLmNsb3NlSWZDbGlja0lubmVyIDogdW5kZWZpbmVkXG4gICAgICB9LCBpbWFnZXMpLCBwcmV2U3JjICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHtcbiAgICAgICAgLy8gTW92ZSB0byBwcmV2aW91cyBpbWFnZSBidXR0b25cbiAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgY2xhc3NOYW1lOiBcInJpbC1wcmV2LWJ1dHRvbiByaWxfX25hdkJ1dHRvbnMgcmlsX19uYXZCdXR0b25QcmV2XCIsXG4gICAgICAgIGtleTogXCJwcmV2XCIsXG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiB0aGlzLnByb3BzLnByZXZMYWJlbCxcbiAgICAgICAgdGl0bGU6IHRoaXMucHJvcHMucHJldkxhYmVsLFxuICAgICAgICBvbkNsaWNrOiAhdGhpcy5pc0FuaW1hdGluZygpID8gdGhpcy5yZXF1ZXN0TW92ZVByZXYgOiB1bmRlZmluZWQgLy8gSWdub3JlIGNsaWNrcyBkdXJpbmcgYW5pbWF0aW9uXG5cbiAgICAgIH0pLCBuZXh0U3JjICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHtcbiAgICAgICAgLy8gTW92ZSB0byBuZXh0IGltYWdlIGJ1dHRvblxuICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICBjbGFzc05hbWU6IFwicmlsLW5leHQtYnV0dG9uIHJpbF9fbmF2QnV0dG9ucyByaWxfX25hdkJ1dHRvbk5leHRcIixcbiAgICAgICAga2V5OiBcIm5leHRcIixcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHRoaXMucHJvcHMubmV4dExhYmVsLFxuICAgICAgICB0aXRsZTogdGhpcy5wcm9wcy5uZXh0TGFiZWwsXG4gICAgICAgIG9uQ2xpY2s6ICF0aGlzLmlzQW5pbWF0aW5nKCkgPyB0aGlzLnJlcXVlc3RNb3ZlTmV4dCA6IHVuZGVmaW5lZCAvLyBJZ25vcmUgY2xpY2tzIGR1cmluZyBhbmltYXRpb25cblxuICAgICAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgLy8gTGlnaHRib3ggdG9vbGJhclxuICAgICAgICBjbGFzc05hbWU6IFwicmlsLXRvb2xiYXIgcmlsX190b29sYmFyXCJcbiAgICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwidWxcIiwge1xuICAgICAgICBjbGFzc05hbWU6IFwicmlsLXRvb2xiYXItbGVmdCByaWxfX3Rvb2xiYXJTaWRlIHJpbF9fdG9vbGJhckxlZnRTaWRlXCJcbiAgICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibGlcIiwge1xuICAgICAgICBjbGFzc05hbWU6IFwicmlsLXRvb2xiYXJfX2l0ZW0gcmlsX190b29sYmFySXRlbVwiXG4gICAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgICBjbGFzc05hbWU6IFwicmlsLXRvb2xiYXJfX2l0ZW1fX2NoaWxkIHJpbF9fdG9vbGJhckl0ZW1DaGlsZFwiXG4gICAgICB9LCBpbWFnZVRpdGxlKSkpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInVsXCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInJpbC10b29sYmFyLXJpZ2h0IHJpbF9fdG9vbGJhclNpZGUgcmlsX190b29sYmFyUmlnaHRTaWRlXCJcbiAgICAgIH0sIHRvb2xiYXJCdXR0b25zICYmIHRvb2xiYXJCdXR0b25zLm1hcChmdW5jdGlvbiAoYnV0dG9uLCBpKSB7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImxpXCIsIHtcbiAgICAgICAgICBrZXk6IFwiYnV0dG9uX1wiLmNvbmNhdChpICsgMSksXG4gICAgICAgICAgY2xhc3NOYW1lOiBcInJpbC10b29sYmFyX19pdGVtIHJpbF9fdG9vbGJhckl0ZW1cIlxuICAgICAgICB9LCBidXR0b24pO1xuICAgICAgfSksIGVuYWJsZVpvb20gJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaVwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJyaWwtdG9vbGJhcl9faXRlbSByaWxfX3Rvb2xiYXJJdGVtXCJcbiAgICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHtcbiAgICAgICAgLy8gTGlnaHRib3ggem9vbSBpbiBidXR0b25cbiAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAga2V5OiBcInpvb20taW5cIixcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHRoaXMucHJvcHMuem9vbUluTGFiZWwsXG4gICAgICAgIHRpdGxlOiB0aGlzLnByb3BzLnpvb21JbkxhYmVsLFxuICAgICAgICBjbGFzc05hbWU6IFsncmlsLXpvb20taW4nLCAncmlsX190b29sYmFySXRlbUNoaWxkJywgJ3JpbF9fYnVpbHRpbkJ1dHRvbicsICdyaWxfX3pvb21JbkJ1dHRvbiddLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoem9vbUxldmVsID09PSBNQVhfWk9PTV9MRVZFTCA/IFsncmlsX19idWlsdGluQnV0dG9uRGlzYWJsZWQnXSA6IFtdKSkuam9pbignICcpLFxuICAgICAgICByZWY6IHRoaXMuem9vbUluQnRuLFxuICAgICAgICBkaXNhYmxlZDogdGhpcy5pc0FuaW1hdGluZygpIHx8IHpvb21MZXZlbCA9PT0gTUFYX1pPT01fTEVWRUwsXG4gICAgICAgIG9uQ2xpY2s6ICF0aGlzLmlzQW5pbWF0aW5nKCkgJiYgem9vbUxldmVsICE9PSBNQVhfWk9PTV9MRVZFTCA/IHRoaXMuaGFuZGxlWm9vbUluQnV0dG9uQ2xpY2sgOiB1bmRlZmluZWRcbiAgICAgIH0pKSwgZW5hYmxlWm9vbSAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImxpXCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInJpbC10b29sYmFyX19pdGVtIHJpbF9fdG9vbGJhckl0ZW1cIlxuICAgICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgICAgICAvLyBMaWdodGJveCB6b29tIG91dCBidXR0b25cbiAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAga2V5OiBcInpvb20tb3V0XCIsXG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiB0aGlzLnByb3BzLnpvb21PdXRMYWJlbCxcbiAgICAgICAgdGl0bGU6IHRoaXMucHJvcHMuem9vbU91dExhYmVsLFxuICAgICAgICBjbGFzc05hbWU6IFsncmlsLXpvb20tb3V0JywgJ3JpbF9fdG9vbGJhckl0ZW1DaGlsZCcsICdyaWxfX2J1aWx0aW5CdXR0b24nLCAncmlsX196b29tT3V0QnV0dG9uJ10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSh6b29tTGV2ZWwgPT09IE1JTl9aT09NX0xFVkVMID8gWydyaWxfX2J1aWx0aW5CdXR0b25EaXNhYmxlZCddIDogW10pKS5qb2luKCcgJyksXG4gICAgICAgIHJlZjogdGhpcy56b29tT3V0QnRuLFxuICAgICAgICBkaXNhYmxlZDogdGhpcy5pc0FuaW1hdGluZygpIHx8IHpvb21MZXZlbCA9PT0gTUlOX1pPT01fTEVWRUwsXG4gICAgICAgIG9uQ2xpY2s6ICF0aGlzLmlzQW5pbWF0aW5nKCkgJiYgem9vbUxldmVsICE9PSBNSU5fWk9PTV9MRVZFTCA/IHRoaXMuaGFuZGxlWm9vbU91dEJ1dHRvbkNsaWNrIDogdW5kZWZpbmVkXG4gICAgICB9KSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibGlcIiwge1xuICAgICAgICBjbGFzc05hbWU6IFwicmlsLXRvb2xiYXJfX2l0ZW0gcmlsX190b29sYmFySXRlbVwiXG4gICAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7XG4gICAgICAgIC8vIExpZ2h0Ym94IGNsb3NlIGJ1dHRvblxuICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICBrZXk6IFwiY2xvc2VcIixcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHRoaXMucHJvcHMuY2xvc2VMYWJlbCxcbiAgICAgICAgdGl0bGU6IHRoaXMucHJvcHMuY2xvc2VMYWJlbCxcbiAgICAgICAgY2xhc3NOYW1lOiBcInJpbC1jbG9zZSByaWwtdG9vbGJhcl9faXRlbV9fY2hpbGQgcmlsX190b29sYmFySXRlbUNoaWxkIHJpbF9fYnVpbHRpbkJ1dHRvbiByaWxfX2Nsb3NlQnV0dG9uXCIsXG4gICAgICAgIG9uQ2xpY2s6ICF0aGlzLmlzQW5pbWF0aW5nKCkgPyB0aGlzLnJlcXVlc3RDbG9zZSA6IHVuZGVmaW5lZCAvLyBJZ25vcmUgY2xpY2tzIGR1cmluZyBhbmltYXRpb25cblxuICAgICAgfSkpKSksIHRoaXMucHJvcHMuaW1hZ2VDYXB0aW9uICYmXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganN4LWExMXkvbm8tc3RhdGljLWVsZW1lbnQtaW50ZXJhY3Rpb25zXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgLy8gSW1hZ2UgY2FwdGlvblxuICAgICAgICBvbldoZWVsOiB0aGlzLmhhbmRsZUNhcHRpb25Nb3VzZXdoZWVsLFxuICAgICAgICBvbk1vdXNlRG93bjogZnVuY3Rpb24gb25Nb3VzZURvd24oZXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNsYXNzTmFtZTogXCJyaWwtY2FwdGlvbiByaWxfX2NhcHRpb25cIixcbiAgICAgICAgcmVmOiB0aGlzLmNhcHRpb25cbiAgICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInJpbC1jYXB0aW9uLWNvbnRlbnQgcmlsX19jYXB0aW9uQ29udGVudFwiXG4gICAgICB9LCB0aGlzLnByb3BzLmltYWdlQ2FwdGlvbikpKSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiaXNUYXJnZXRNYXRjaEltYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzVGFyZ2V0TWF0Y2hJbWFnZSh0YXJnZXQpIHtcbiAgICAgIHJldHVybiB0YXJnZXQgJiYgL3JpbC1pbWFnZS1jdXJyZW50Ly50ZXN0KHRhcmdldC5jbGFzc05hbWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZU1vdXNlRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VNb3VzZUV2ZW50KG1vdXNlRXZlbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiAnbW91c2UnLFxuICAgICAgICBzb3VyY2U6IFNPVVJDRV9NT1VTRSxcbiAgICAgICAgeDogcGFyc2VJbnQobW91c2VFdmVudC5jbGllbnRYLCAxMCksXG4gICAgICAgIHk6IHBhcnNlSW50KG1vdXNlRXZlbnQuY2xpZW50WSwgMTApXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZVRvdWNoUG9pbnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZVRvdWNoUG9pbnRlcih0b3VjaFBvaW50ZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiB0b3VjaFBvaW50ZXIuaWRlbnRpZmllcixcbiAgICAgICAgc291cmNlOiBTT1VSQ0VfVE9VQ0gsXG4gICAgICAgIHg6IHBhcnNlSW50KHRvdWNoUG9pbnRlci5jbGllbnRYLCAxMCksXG4gICAgICAgIHk6IHBhcnNlSW50KHRvdWNoUG9pbnRlci5jbGllbnRZLCAxMClcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlUG9pbnRlckV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlUG9pbnRlckV2ZW50KHBvaW50ZXJFdmVudCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IHBvaW50ZXJFdmVudC5wb2ludGVySWQsXG4gICAgICAgIHNvdXJjZTogU09VUkNFX1BPSU5URVIsXG4gICAgICAgIHg6IHBhcnNlSW50KHBvaW50ZXJFdmVudC5jbGllbnRYLCAxMCksXG4gICAgICAgIHk6IHBhcnNlSW50KHBvaW50ZXJFdmVudC5jbGllbnRZLCAxMClcbiAgICAgIH07XG4gICAgfSAvLyBSZXF1ZXN0IHRvIHRyYW5zaXRpb24gdG8gdGhlIHByZXZpb3VzIGltYWdlXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRUcmFuc2Zvcm1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHJhbnNmb3JtKF9yZWYxMykge1xuICAgICAgdmFyIF9yZWYxMyR4ID0gX3JlZjEzLngsXG4gICAgICAgICAgeCA9IF9yZWYxMyR4ID09PSB2b2lkIDAgPyAwIDogX3JlZjEzJHgsXG4gICAgICAgICAgX3JlZjEzJHkgPSBfcmVmMTMueSxcbiAgICAgICAgICB5ID0gX3JlZjEzJHkgPT09IHZvaWQgMCA/IDAgOiBfcmVmMTMkeSxcbiAgICAgICAgICBfcmVmMTMkem9vbSA9IF9yZWYxMy56b29tLFxuICAgICAgICAgIHpvb20gPSBfcmVmMTMkem9vbSA9PT0gdm9pZCAwID8gMSA6IF9yZWYxMyR6b29tLFxuICAgICAgICAgIHdpZHRoID0gX3JlZjEzLndpZHRoLFxuICAgICAgICAgIHRhcmdldFdpZHRoID0gX3JlZjEzLnRhcmdldFdpZHRoO1xuICAgICAgdmFyIG5leHRYID0geDtcbiAgICAgIHZhciB3aW5kb3dXaWR0aCA9IGdldFdpbmRvd1dpZHRoKCk7XG5cbiAgICAgIGlmICh3aWR0aCA+IHdpbmRvd1dpZHRoKSB7XG4gICAgICAgIG5leHRYICs9ICh3aW5kb3dXaWR0aCAtIHdpZHRoKSAvIDI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzY2FsZUZhY3RvciA9IHpvb20gKiAodGFyZ2V0V2lkdGggLyB3aWR0aCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlM2QoXCIuY29uY2F0KG5leHRYLCBcInB4LFwiKS5jb25jYXQoeSwgXCJweCwwKSBzY2FsZTNkKFwiKS5jb25jYXQoc2NhbGVGYWN0b3IsIFwiLFwiKS5jb25jYXQoc2NhbGVGYWN0b3IsIFwiLDEpXCIpXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZWFjdEltYWdlTGlnaHRib3g7XG59KENvbXBvbmVudCk7XG5cblJlYWN0SW1hZ2VMaWdodGJveC5wcm9wVHlwZXMgPSB7XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gSW1hZ2Ugc291cmNlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIE1haW4gZGlzcGxheSBpbWFnZSB1cmxcbiAgbWFpblNyYzogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlYWN0L25vLXVudXNlZC1wcm9wLXR5cGVzXG4gIC8vIFByZXZpb3VzIGRpc3BsYXkgaW1hZ2UgdXJsIChkaXNwbGF5ZWQgdG8gdGhlIGxlZnQpXG4gIC8vIElmIGxlZnQgdW5kZWZpbmVkLCBtb3ZlUHJldiBhY3Rpb25zIHdpbGwgbm90IGJlIHBlcmZvcm1lZCwgYW5kIHRoZSBidXR0b24gbm90IGRpc3BsYXllZFxuICBwcmV2U3JjOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAvLyBOZXh0IGRpc3BsYXkgaW1hZ2UgdXJsIChkaXNwbGF5ZWQgdG8gdGhlIHJpZ2h0KVxuICAvLyBJZiBsZWZ0IHVuZGVmaW5lZCwgbW92ZU5leHQgYWN0aW9ucyB3aWxsIG5vdCBiZSBwZXJmb3JtZWQsIGFuZCB0aGUgYnV0dG9uIG5vdCBkaXNwbGF5ZWRcbiAgbmV4dFNyYzogUHJvcFR5cGVzLnN0cmluZyxcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBJbWFnZSB0aHVtYm5haWwgc291cmNlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFRodW1ibmFpbCBpbWFnZSB1cmwgY29ycmVzcG9uZGluZyB0byBwcm9wcy5tYWluU3JjXG4gIG1haW5TcmNUaHVtYm5haWw6IFByb3BUeXBlcy5zdHJpbmcsXG4gIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVhY3Qvbm8tdW51c2VkLXByb3AtdHlwZXNcbiAgLy8gVGh1bWJuYWlsIGltYWdlIHVybCBjb3JyZXNwb25kaW5nIHRvIHByb3BzLnByZXZTcmNcbiAgcHJldlNyY1RodW1ibmFpbDogUHJvcFR5cGVzLnN0cmluZyxcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZWFjdC9uby11bnVzZWQtcHJvcC10eXBlc1xuICAvLyBUaHVtYm5haWwgaW1hZ2UgdXJsIGNvcnJlc3BvbmRpbmcgdG8gcHJvcHMubmV4dFNyY1xuICBuZXh0U3JjVGh1bWJuYWlsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlYWN0L25vLXVudXNlZC1wcm9wLXR5cGVzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gRXZlbnQgSGFuZGxlcnNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBDbG9zZSB3aW5kb3cgZXZlbnRcbiAgLy8gU2hvdWxkIGNoYW5nZSB0aGUgcGFyZW50IHN0YXRlIHN1Y2ggdGhhdCB0aGUgbGlnaHRib3ggaXMgbm90IHJlbmRlcmVkXG4gIG9uQ2xvc2VSZXF1ZXN0OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAvLyBNb3ZlIHRvIHByZXZpb3VzIGltYWdlIGV2ZW50XG4gIC8vIFNob3VsZCBjaGFuZ2UgdGhlIHBhcmVudCBzdGF0ZSBzdWNoIHRoYXQgcHJvcHMucHJldlNyYyBiZWNvbWVzIHByb3BzLm1haW5TcmMsXG4gIC8vICBwcm9wcy5tYWluU3JjIGJlY29tZXMgcHJvcHMubmV4dFNyYywgZXRjLlxuICBvbk1vdmVQcmV2UmVxdWVzdDogUHJvcFR5cGVzLmZ1bmMsXG4gIC8vIE1vdmUgdG8gbmV4dCBpbWFnZSBldmVudFxuICAvLyBTaG91bGQgY2hhbmdlIHRoZSBwYXJlbnQgc3RhdGUgc3VjaCB0aGF0IHByb3BzLm5leHRTcmMgYmVjb21lcyBwcm9wcy5tYWluU3JjLFxuICAvLyAgcHJvcHMubWFpblNyYyBiZWNvbWVzIHByb3BzLnByZXZTcmMsIGV0Yy5cbiAgb25Nb3ZlTmV4dFJlcXVlc3Q6IFByb3BUeXBlcy5mdW5jLFxuICAvLyBDYWxsZWQgd2hlbiBhbiBpbWFnZSBmYWlscyB0byBsb2FkXG4gIC8vIChpbWFnZVNyYzogc3RyaW5nLCBzcmNUeXBlOiBzdHJpbmcsIGVycm9yRXZlbnQ6IG9iamVjdCk6IHZvaWRcbiAgb25JbWFnZUxvYWRFcnJvcjogUHJvcFR5cGVzLmZ1bmMsXG4gIC8vIENhbGxlZCB3aGVuIGltYWdlIHN1Y2Nlc3NmdWxseSBsb2Fkc1xuICBvbkltYWdlTG9hZDogUHJvcFR5cGVzLmZ1bmMsXG4gIC8vIE9wZW4gd2luZG93IGV2ZW50XG4gIG9uQWZ0ZXJPcGVuOiBQcm9wVHlwZXMuZnVuYyxcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBEb3dubG9hZCBkaXNjb3VyYWdlbWVudCBzZXR0aW5nc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIEVuYWJsZSBkb3dubG9hZCBkaXNjb3VyYWdlbWVudCAocHJldmVudHMgW3JpZ2h0LWNsaWNrIC0+IFNhdmUgSW1hZ2UgQXMuLi5dKVxuICBkaXNjb3VyYWdlRG93bmxvYWRzOiBQcm9wVHlwZXMuYm9vbCxcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBBbmltYXRpb24gc2V0dGluZ3NcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBEaXNhYmxlIGFsbCBhbmltYXRpb25cbiAgYW5pbWF0aW9uRGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAvLyBEaXNhYmxlIGFuaW1hdGlvbiBvbiBhY3Rpb25zIHBlcmZvcm1lZCB3aXRoIGtleWJvYXJkIHNob3J0Y3V0c1xuICBhbmltYXRpb25PbktleUlucHV0OiBQcm9wVHlwZXMuYm9vbCxcbiAgLy8gQW5pbWF0aW9uIGR1cmF0aW9uIChtcylcbiAgYW5pbWF0aW9uRHVyYXRpb246IFByb3BUeXBlcy5udW1iZXIsXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gS2V5Ym9hcmQgc2hvcnRjdXQgc2V0dGluZ3NcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBSZXF1aXJlZCBpbnRlcnZhbCBvZiB0aW1lIChtcykgYmV0d2VlbiBrZXkgYWN0aW9uc1xuICAvLyAocHJldmVudHMgZXhjZXNzaXZlbHkgZmFzdCBuYXZpZ2F0aW9uIG9mIGltYWdlcylcbiAga2V5UmVwZWF0TGltaXQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIC8vIEFtb3VudCBvZiB0aW1lIChtcykgcmVzdG9yZWQgYWZ0ZXIgZWFjaCBrZXl1cFxuICAvLyAobWFrZXMgcmFwaWQga2V5IHByZXNzZXMgc2xpZ2h0bHkgZmFzdGVyIHRoYW4gaG9sZGluZyBkb3duIHRoZSBrZXkgdG8gbmF2aWdhdGUgaW1hZ2VzKVxuICBrZXlSZXBlYXRLZXl1cEJvbnVzOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIEltYWdlIGluZm9cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBJbWFnZSB0aXRsZVxuICBpbWFnZVRpdGxlOiBQcm9wVHlwZXMubm9kZSxcbiAgLy8gSW1hZ2UgY2FwdGlvblxuICBpbWFnZUNhcHRpb246IFByb3BUeXBlcy5ub2RlLFxuICAvLyBPcHRpb25hbCBjcm9zc09yaWdpbiBhdHRyaWJ1dGVcbiAgaW1hZ2VDcm9zc09yaWdpbjogUHJvcFR5cGVzLnN0cmluZyxcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBMaWdodGJveCBzdHlsZVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFNldCB6LWluZGV4IHN0eWxlLCBldGMuLCBmb3IgdGhlIHBhcmVudCByZWFjdC1tb2RhbCAoZm9ybWF0OiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC1tb2RhbCNzdHlsZXMgKVxuICByZWFjdE1vZGFsU3R5bGU6IFByb3BUeXBlcy5zaGFwZSh7fSksXG4gIC8vIFBhZGRpbmcgKHB4KSBiZXR3ZWVuIHRoZSBlZGdlIG9mIHRoZSB3aW5kb3cgYW5kIHRoZSBsaWdodGJveFxuICBpbWFnZVBhZGRpbmc6IFByb3BUeXBlcy5udW1iZXIsXG4gIHdyYXBwZXJDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gT3RoZXJcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBBcnJheSBvZiBjdXN0b20gdG9vbGJhciBidXR0b25zXG4gIHRvb2xiYXJCdXR0b25zOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMubm9kZSksXG4gIC8vIFdoZW4gdHJ1ZSwgY2xpY2tzIG91dHNpZGUgb2YgdGhlIGltYWdlIGNsb3NlIHRoZSBsaWdodGJveFxuICBjbGlja091dHNpZGVUb0Nsb3NlOiBQcm9wVHlwZXMuYm9vbCxcbiAgLy8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgem9vbSBmdW5jdGlvbmFsaXR5IGFuZCBoaWRlIHpvb20gYnV0dG9uc1xuICBlbmFibGVab29tOiBQcm9wVHlwZXMuYm9vbCxcbiAgLy8gT3ZlcnJpZGUgcHJvcHMgc2V0IG9uIHJlYWN0LW1vZGFsIChodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC1tb2RhbClcbiAgcmVhY3RNb2RhbFByb3BzOiBQcm9wVHlwZXMuc2hhcGUoe30pLFxuICAvLyBBcmlhLWxhYmVsc1xuICBuZXh0TGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHByZXZMYWJlbDogUHJvcFR5cGVzLnN0cmluZyxcbiAgem9vbUluTGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHpvb21PdXRMYWJlbDogUHJvcFR5cGVzLnN0cmluZyxcbiAgY2xvc2VMYWJlbDogUHJvcFR5cGVzLnN0cmluZyxcbiAgaW1hZ2VMb2FkRXJyb3JNZXNzYWdlOiBQcm9wVHlwZXMubm9kZSxcbiAgLy8gY3VzdG9tIGxvYWRlclxuICBsb2FkZXI6IFByb3BUeXBlcy5ub2RlXG59O1xuUmVhY3RJbWFnZUxpZ2h0Ym94LmRlZmF1bHRQcm9wcyA9IHtcbiAgaW1hZ2VUaXRsZTogbnVsbCxcbiAgaW1hZ2VDYXB0aW9uOiBudWxsLFxuICB0b29sYmFyQnV0dG9uczogbnVsbCxcbiAgcmVhY3RNb2RhbFByb3BzOiB7fSxcbiAgYW5pbWF0aW9uRGlzYWJsZWQ6IGZhbHNlLFxuICBhbmltYXRpb25EdXJhdGlvbjogMzAwLFxuICBhbmltYXRpb25PbktleUlucHV0OiBmYWxzZSxcbiAgY2xpY2tPdXRzaWRlVG9DbG9zZTogdHJ1ZSxcbiAgY2xvc2VMYWJlbDogJ0Nsb3NlIGxpZ2h0Ym94JyxcbiAgZGlzY291cmFnZURvd25sb2FkczogZmFsc2UsXG4gIGVuYWJsZVpvb206IHRydWUsXG4gIGltYWdlUGFkZGluZzogMTAsXG4gIGltYWdlQ3Jvc3NPcmlnaW46IG51bGwsXG4gIGtleVJlcGVhdEtleXVwQm9udXM6IDQwLFxuICBrZXlSZXBlYXRMaW1pdDogMTgwLFxuICBtYWluU3JjVGh1bWJuYWlsOiBudWxsLFxuICBuZXh0TGFiZWw6ICdOZXh0IGltYWdlJyxcbiAgbmV4dFNyYzogbnVsbCxcbiAgbmV4dFNyY1RodW1ibmFpbDogbnVsbCxcbiAgb25BZnRlck9wZW46IGZ1bmN0aW9uIG9uQWZ0ZXJPcGVuKCkge30sXG4gIG9uSW1hZ2VMb2FkRXJyb3I6IGZ1bmN0aW9uIG9uSW1hZ2VMb2FkRXJyb3IoKSB7fSxcbiAgb25JbWFnZUxvYWQ6IGZ1bmN0aW9uIG9uSW1hZ2VMb2FkKCkge30sXG4gIG9uTW92ZU5leHRSZXF1ZXN0OiBmdW5jdGlvbiBvbk1vdmVOZXh0UmVxdWVzdCgpIHt9LFxuICBvbk1vdmVQcmV2UmVxdWVzdDogZnVuY3Rpb24gb25Nb3ZlUHJldlJlcXVlc3QoKSB7fSxcbiAgcHJldkxhYmVsOiAnUHJldmlvdXMgaW1hZ2UnLFxuICBwcmV2U3JjOiBudWxsLFxuICBwcmV2U3JjVGh1bWJuYWlsOiBudWxsLFxuICByZWFjdE1vZGFsU3R5bGU6IHt9LFxuICB3cmFwcGVyQ2xhc3NOYW1lOiAnJyxcbiAgem9vbUluTGFiZWw6ICdab29tIGluJyxcbiAgem9vbU91dExhYmVsOiAnWm9vbSBvdXQnLFxuICBpbWFnZUxvYWRFcnJvck1lc3NhZ2U6ICdUaGlzIGltYWdlIGZhaWxlZCB0byBsb2FkJyxcbiAgbG9hZGVyOiB1bmRlZmluZWRcbn07XG5cbmV4cG9ydCB7IFJlYWN0SW1hZ2VMaWdodGJveCBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-18-image-lightbox/dist/index.es.js\n");

/***/ })

};
;